#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  README auxDir check.1 compile destroyoldkey.1 dumpsig.1
#   h.c makepublickey.1 md4.c md4.h md4Block.c privDir pubDir
#   recoverauxinfo.1 sb.c sign.1 signCheck1.0.c test testit
#   wellKnownDirectories
# Wrapped by merkle@manarken on Wed Nov 13 15:37:11 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(238 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is a highly experimental version of the software.
XTo compile it, execute the shell file "compile".
XTo test it, execute the shell file "testit".
XTo use it, read the "man" entries for:
X"makepublickey", "sign", and "check".
X
XGood luck!
END_OF_FILE
if test 238 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'auxDir' ; then
    echo shar: Creating directory \"'auxDir'\"
    mkdir 'auxDir'
fi
if test -f 'check.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'check.1'\"
else
echo shar: Extracting \"'check.1'\" \(1513 characters\)
sed "s/^X//" >'check.1' <<'END_OF_FILE'
X.TH "CHECK" 1 "May 8, 1990" "Hash Signatures"
X.SH NAME
Xcheck - check the digital signature on a file
X.SH FOR EXPERIMENTAL USE ONLY
X
X.SH SYNOPSIS
Xcheck [ -s ] [ -v ] [ -dDirectory ] file(s)
X.SH DESCRIPTION
X.B Check
Xchecks the digital signature of the given files.  If the
X"-dDirectory" option is given, then check will look in
Xthe specified directory for the public keys and will not
Xlook in the standard directory.  If the "-s" flag is
Xspecified, all output is suppressed (which is useful when
Xcheck is used in a shell file -- see below).  If the "-v" option is
Xgiven, the message (if any) which was added to the signature
Xduring the signing process is printed out.  A status return
Xof 0 indicates that the signatures for all the given files
Xwere valid, and that valid public keys were found for all
Xthe signatures in the public key directory.  This is useful
Xwhen a shell script wants to confirm that the files have
Xall been properly signed, but does not want to actually look
Xat the text output produced by "check."
X.SH EXAMPLES
Xcheck /bin/*
X.PP
XChecks all the files in /bin.  Modification of any of the
Xfiles (by, for example, a virus) since the time the
Xfiles were signed will be detected.  Deletion of a file
Xwill not be detected.
X
X.SH FILES
X"check" expects to find public checking keys in the public directory:
X/net/palain/rouge/pubdir.
X.SH "SEE ALSO"
Xsign(1) makepublickey(1) destroyoldkey(1) dumpsig(1) recoverauxinfo(1)
X.SH AUTHOR
XRalph C. Merkle
XCopyright (C) 1990 Xerox Corporation
XAll Rights Reserved
END_OF_FILE
if test 1513 -ne `wc -c <'check.1'`; then
    echo shar: \"'check.1'\" unpacked with wrong size!
fi
# end of 'check.1'
fi
if test -f 'compile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compile'\"
else
echo shar: Extracting \"'compile'\" \(266 characters\)
sed "s/^X//" >'compile' <<'END_OF_FILE'
Xrm -f sign check makepublickey dumpsig destroyoldkey recoverauxinfo
Xcc -g -o sign signCheck1.0.c h.c sb.c md4Block.c md4.c
Xln sign check
Xln sign makepublickey
Xln sign dumpsig
Xln sign destroyoldkey
Xln sign recoverauxinfo
Xlint signCheck1.0.c h.c sb.c md4.c md4Block.c
END_OF_FILE
if test 266 -ne `wc -c <'compile'`; then
    echo shar: \"'compile'\" unpacked with wrong size!
fi
chmod +x 'compile'
# end of 'compile'
fi
if test -f 'destroyoldkey.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'destroyoldkey.1'\"
else
echo shar: Extracting \"'destroyoldkey.1'\" \(1073 characters\)
sed "s/^X//" >'destroyoldkey.1' <<'END_OF_FILE'
X.TH "DESTROYOLDKEY" 1 "May 8, 1990" "Hash Signatures"
X.SH NAME
Xdestroyoldkey - destroy the machine key of the user
X.SH FOR EXPERIMENTAL USE ONLY
X
X.SH SYNOPSIS
Xdestroyoldkey
X.SH DESCRIPTION
X.B Destroyoldkey
Xdestroys the users machine key.  Following destruction of the machine key, the secret key cannot be recovered.  It is gone.  Permanently.  Previously made signatures can still be checked for validity by using the public key, which is never destroyed.  "Destroyoldkey" is normally used when the user wishes to change the secret key as a routine security precaution, or when the user suspects the key might have been compromised, and wishes to use a new key.
X.SH EXAMPLES
Xdestroyoldkey
X.PP
XThe user's machine key is destroyed, which means
Xthe secret signing key is unrecoverable.
X.SH FILES
X"destroyoldkey" expects to find the secret signing keys in:
X/net/palain/rouge/privdir and
X/net/palain/jaune/privdir.
X.SH "SEE ALSO"
Xcheck(1) sign(1) makepublickey(1) dumpsig(1) recoverauxinfo(1)
X.SH AUTHOR
XRalph C. Merkle
XCopyright (C) 1990 Xerox Corporation
XAll Rights Reserved
END_OF_FILE
if test 1073 -ne `wc -c <'destroyoldkey.1'`; then
    echo shar: \"'destroyoldkey.1'\" unpacked with wrong size!
fi
# end of 'destroyoldkey.1'
fi
if test -f 'dumpsig.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dumpsig.1'\"
else
echo shar: Extracting \"'dumpsig.1'\" \(554 characters\)
sed "s/^X//" >'dumpsig.1' <<'END_OF_FILE'
X.TH "DUMPSIG" 1 "May 8, 1990" "Hash Signatures"
X.SH NAME
Xdumpsig - dump a signature in a more-or-less readable format
X.SH FOR EXPERIMENTAL USE ONLY
X
X.SH SYNOPSIS
Xdumpsig file
X.SH DESCRIPTION
X.B Dumpsig
Xdumps the signature for the specified file.  Intended primarily for debugging purposes.
X.SH EXAMPLES
Xdumpsig contract
X.PP
XThe signature for file "contract" is printed on standard out.
X.SH "SEE ALSO"
Xcheck(1) sign(1) destroyoldkey(1) makepublickey(1) recoverauxinfo(1)
X.SH AUTHOR
XRalph C. Merkle
XCopyright (C) 1990 Xerox Corporation
XAll Rights Reserved
END_OF_FILE
if test 554 -ne `wc -c <'dumpsig.1'`; then
    echo shar: \"'dumpsig.1'\" unpacked with wrong size!
fi
# end of 'dumpsig.1'
fi
if test -f 'h.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'h.c'\"
else
echo shar: Extracting \"'h.c'\" \(22749 characters\)
sed "s/^X//" >'h.c' <<'END_OF_FILE'
X/*
X * This file contains some of the hash methods and hash-function
X * specific information.  At the present time, it includes a
X * very slow and inefficient implementation of Snefru.  It calls
X * MD4, the implementation of which is included in another file.
X * Further hash functions can be added in the future as warranted.
X * Please contact Ralph C. Merkle before doing so to insure that the
X * constant value assigned to the new hash method is unique and does
X * not collide with other values.  In any event, values below 100
X * are reserved for use by Xerox.
X */
X/*
X  Copyright (c) Xerox Corporation 1990.  All rights reserved.
X  
X  The following notices apply to the implementation of Snefru and
X  related software contained in this file.  They do not apply
X  to the other files included with this software, which include
X  implementations of MD4 and of the Abstract Xerox Hash Signature.
X  Please refer to the appropriate notices.
X
X  License to copy and use this software (an implementation of Snefru)
X  is granted provided that it is identified as the "Xerox Secure Hash
X  Function" in all material mentioning or referencing this software
X  or this hash function.
X  
X  License is also granted to make and use derivative works provided that such
X  works are identified as "derived from the Xerox Secure Hash Function" in
X  all material mentioning or referencing the derived work.
X
X  XEROX CORPORATION MAKES NO REPRESENTATIONS CONCERNING EITHER THE
X  MERCHANTABILITY OF THIS SOFTWARE OR THE SUITABILITY OF THIS SOFTWARE FOR
X  ANY PARTICULAR PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED
X  WARRANTY OF ANY KIND.
X  
X  These notices must be retained in any copies of any part of this software.
X  
X  Updated information about Snefru is available from arisia.xerox.com in
X  directory /pub/hash by anonymous FTP.  The README file provides a quick
X  introduction to the subdirectories.
X*/
X#include <stdio.h>
X#define MAX_INPUT_BLOCK_SIZE 16
X#define SNEFRU_INPUT_BLOCK_SIZE 16
X#define OUTPUT_BLOCK_SIZE 8
X#define MAX_SBOX_COUNT 8
X#define MD4_METHOD 100
X#define SNEFRU3_METHOD 3
X#define SNEFRU4_METHOD 4
X#define SNEFRU512_INPUT_BLOCK_SIZE 16
X#define SNEFRU384_INPUT_BLOCK_SIZE 12
X#define SNEFRU256_INPUT_BLOCK_SIZE 8
X#define SNEFRU128_INPUT_BLOCK_SIZE 4
X#define DEBUG_SNEFRU 0
X
X#define round512(L,C,N,SB)	SBE=SB[C&0xffL];L^=SBE;N^=SBE
X#define rotate512(B)	B=(B>>shift) | (B<<leftShift)
X
Xextern void ErrAbort();
Xextern void Copy();
Xextern void Md4Block();
Xextern void PrintIt();
Xextern void Increment64BitCounter();
X
Xtypedef unsigned long int word32;
Xint     shiftTable[4] = {16, 8, 16, 24};
X
X/* The standard S boxes must be defined in another file */
Xextern word32 standardSBoxes[MAX_SBOX_COUNT][256];
X
Xvoid    SnefruBlock (output, outputBlockSize,
X		input, inputBlockSize, securityLevel)
X	word32 output[/* outputBlockSize */];
X	int outputBlockSize;
X	word32 input[/* inputBlockSize */];
X	int     inputBlockSize;
X	int     securityLevel;
X{
X
X	/* holds the array of data being hashed  */
X	word32 block[MAX_INPUT_BLOCK_SIZE];
X	word32 SBoxEntry;	/* just a temporary */
X	int     shift;
X	int     i;
X	int     index;
X	int     next, last;
X	int     byteInWord;
X
X	/* Test for various error conditions and logic problems  */
X	if (securityLevel * 2 > MAX_SBOX_COUNT)
X		ErrAbort ("Too few S-boxes");
X	if (outputBlockSize < 2)
X		ErrAbort (" outputBlockSize too small");
X	if ( outputBlockSize > inputBlockSize)
X		ErrAbort ("logic error, outputBlockSize is too big");
X
X	/* initialize the block to be hashed from the input  */
X	Copy(block, input, inputBlockSize);
X	/*  increase block size till it's a multiple of 4 words
X	    and pad the new words with 0's */
X	while ( (inputBlockSize & 3) != 0 )
X		block[inputBlockSize++] = 0L;
X
X	/*  complete error testing with updated inputBlockSize  */
X	if ( (outputBlockSize+2) > inputBlockSize)
X		ErrAbort ("logic error, inputBlockSize is too small");
X	if (inputBlockSize > MAX_INPUT_BLOCK_SIZE)
X		ErrAbort ("Logic error, inputBlockSize > MAX_INPUT_BLOCK_SIZE");
X	/* All the error conditions have now been checked -- everything should
X	   work smoothly  */
X	/* Note that we are computing securityLevel * inputBlockSize * 4
X	   rounds.  */
X	for (index = 0; index < securityLevel; index++) {
X
X
X		for (byteInWord = 0; byteInWord < 4; byteInWord++) {
X
X
X			for (i = 0; i < inputBlockSize; i++) {
X				
X				next = (i + 1) % inputBlockSize;
X				/*  last = (i-1) MOD inputBlockSize */
X				last = (i + inputBlockSize - 1) %
X					inputBlockSize;
X
X
X				SBoxEntry = standardSBoxes
X					[2 * index + ((i / 2) & 1)]
X					[block[i] & 0xff];
X				block[next] ^= SBoxEntry;
X				block[last] ^= SBoxEntry;
X			};
X
X
X			/* Rotate right all 32-bit words in the entire block
X			   at once.  */
X			shift = shiftTable[byteInWord];
X			for (i = 0; i < inputBlockSize; i++)
X				block[i] =	(block[i] >> shift) |
X						(block[i] << (32 - shift));
X
X
X		};		/* end of byteInWord going from 0 to 3 */
X
X
X	};			/* end of index going from 0 to
X				   securityLevel-1 */
X
X
X
X	for (i = 0; i < outputBlockSize; i++)
X		output[i] = input[i] ^ block[inputBlockSize - 1 - i];
X
X
X}
X
X
X/*
X * Snefru512 is a more efficient and specialized version of SnefruBlock.
X * It accepts an input of 16 32-bit words and produces an output of
X * 32-bit words.  The output size cannot be bigger than 14 32-bit words,
X * or a serious degradation in security will occur.
X */
Xvoid
XSnefru512 (output, outputBlockSize, input, inputBlockSize, securityLevel)
X	word32	output[];
X	int	outputBlockSize;
X	word32	input[SNEFRU512_INPUT_BLOCK_SIZE];
X	int	inputBlockSize;
X	int	securityLevel;
X{
X	static int shiftTable[4] = {16, 8, 16, 24};
X	/* the array of data being hashed  */
X	word32	SBE;	/* just a temporary */
X	int     shift, leftShift;
X	int     index;
X	int     byteInWord;
X	word32	*SBox0;
X	word32	*SBox1;
X	word32	B00,B01,B02,B03,B04,B05,B06,B07,B08,B09,B10,B11,B12,B13,B14,B15;
X
X	/* initialize the block to be hashed from the input  */
X	B00 = input[0];
X	B01 = input[1];
X	B02 = input[2];
X	B03 = input[3];
X	B04 = input[4];
X	B05 = input[5];
X	B06 = input[6];
X	B07 = input[7];
X	B08 = input[8];
X	B09 = input[9];
X	B10 = input[10];
X	B11 = input[11];
X	B12 = 0;
X	B13 = 0;
X	B14 = 0;
X	B15 = 0;
X	switch (inputBlockSize) {
X	case 16:	B15 = input[15];
X	case 15:	B14 = input[14];
X	case 14:	B13 = input[13];
X	case 13:	B12 = input[12];
X		break;
X	default:	ErrAbort("bad input size to snefru512");
X	};
X
X	for (index = 0; index < securityLevel; index++) {
X		SBox0 = standardSBoxes[2*index+0];
X		SBox1 = standardSBoxes[2*index+1];
X		for (byteInWord = 0; byteInWord < 4; byteInWord++) {
X			round512(B15,B00,B01,SBox0);
X			round512(B00,B01,B02,SBox0);
X			round512(B01,B02,B03,SBox1);
X			round512(B02,B03,B04,SBox1);
X			round512(B03,B04,B05,SBox0);
X			round512(B04,B05,B06,SBox0);
X			round512(B05,B06,B07,SBox1);
X			round512(B06,B07,B08,SBox1);
X			round512(B07,B08,B09,SBox0);
X			round512(B08,B09,B10,SBox0);
X			round512(B09,B10,B11,SBox1);
X			round512(B10,B11,B12,SBox1);
X			round512(B11,B12,B13,SBox0);
X			round512(B12,B13,B14,SBox0);
X			round512(B13,B14,B15,SBox1);
X			round512(B14,B15,B00,SBox1);
X			/*
X			 * Rotate right all 32-bit words in the entire block
X			 * at once.
X			 */
X			shift = shiftTable[byteInWord];
X			leftShift = 32-shift;
X			rotate512(B00);
X			rotate512(B01);
X			rotate512(B02);
X			rotate512(B03);
X			rotate512(B04);
X			rotate512(B05);
X			rotate512(B06);
X			rotate512(B07);
X			rotate512(B08);
X			rotate512(B09);
X			rotate512(B10);
X			rotate512(B11);
X			rotate512(B12);
X			rotate512(B13);
X			rotate512(B14);
X			rotate512(B15);
X		};		/* end of byteInWord going from 0 to 3 */
X	};			/* end of index going from 0 to
X				 * securityLevel-1 */
X
X	switch (outputBlockSize) {
X	case 14:	output[13] = input[13] ^ B02;
X	case 13:	output[12] = input[12] ^ B03;
X	case 12:	output[11] = input[11] ^ B04;
X	case 11:	output[10] = input[10] ^ B05;
X	case 10:	output[ 9] = input[ 9] ^ B06;
X	case  9:	output[ 8] = input[ 8] ^ B07;
X	case  8:	output[ 7] = input[ 7] ^ B08;
X	case  7:	output[ 6] = input[ 6] ^ B09;
X	case  6:	output[ 5] = input[ 5] ^ B10;
X	case  5:	output[ 4] = input[ 4] ^ B11;
X	case  4:	output[ 3] = input[ 3] ^ B12;
X	case  3:	output[ 2] = input[ 2] ^ B13;
X	case  2:	output[ 1] = input[ 1] ^ B14;
X	case  1:	output[ 0] = input[ 0] ^ B15;
X			break;
X	default: ErrAbort("Bad output block size");
X	};
X};
X
X/*
X * Snefru384 is a more efficient and specialized version of SnefruBlock.
X * It accepts an input of 12 32-bit words and produces an output of
X * outputBlockSize 32-bit words.  The output size cannot be bigger
X * than 10 32-bit words, or a serious degradation in security will occur.
X */
Xvoid
XSnefru384 (output, outputBlockSize, input, inputBlockSize, securityLevel)
X	word32	output[];
X	int	outputBlockSize;
X	word32	input[SNEFRU384_INPUT_BLOCK_SIZE];
X	int	inputBlockSize;
X	int	securityLevel;
X{
X	static int shiftTable[4] = {16, 8, 16, 24};
X	/* the array of data being hashed  */
X	word32	SBE;	/* just a temporary */
X	int     shift, leftShift;
X	int     index;
X	int     byteInWord;
X	word32	*SBox0;
X	word32	*SBox1;
X	word32	B00,B01,B02,B03,B04,B05,B06,B07,B08,B09,B10,B11;
X
X	/* initialize the block to be hashed from the input  */
X	B00 = input[0];
X	B01 = input[1];
X	B02 = input[2];
X	B03 = input[3];
X	B04 = input[4];
X	B05 = input[5];
X	B06 = input[6];
X	B07 = input[7];
X	B08 = 0;
X	B09 = 0;
X	B10 = 0;
X	B11 = 0;
X	switch (inputBlockSize) {
X	case 12:	B11 = input[11];
X	case 11:	B10 = input[10];
X	case 10:	B09 = input[9];
X	case  9:	B08 = input[8];
X		break;
X	default:	ErrAbort("bad input size to snefru384");
X	};
X
X
X
X	for (index = 0; index < securityLevel; index++) {
X		SBox0 = standardSBoxes[2*index+0];
X		SBox1 = standardSBoxes[2*index+1];
X		for (byteInWord = 0; byteInWord < 4; byteInWord++) {
X			round512(B11,B00,B01,SBox0);
X			round512(B00,B01,B02,SBox0);
X			round512(B01,B02,B03,SBox1);
X			round512(B02,B03,B04,SBox1);
X			round512(B03,B04,B05,SBox0);
X			round512(B04,B05,B06,SBox0);
X			round512(B05,B06,B07,SBox1);
X			round512(B06,B07,B08,SBox1);
X			round512(B07,B08,B09,SBox0);
X			round512(B08,B09,B10,SBox0);
X			round512(B09,B10,B11,SBox1);
X			round512(B10,B11,B00,SBox1);
X			/*
X			 * Rotate right all 32-bit words in the entire block
X			 * at once.
X			 */
X			shift = shiftTable[byteInWord];
X			leftShift = 32-shift;
X			rotate512(B00);
X			rotate512(B01);
X			rotate512(B02);
X			rotate512(B03);
X			rotate512(B04);
X			rotate512(B05);
X			rotate512(B06);
X			rotate512(B07);
X			rotate512(B08);
X			rotate512(B09);
X			rotate512(B10);
X			rotate512(B11);
X		};		/* end of byteInWord going from 0 to 3 */
X	};			/* end of index going from 0 to
X				 * securityLevel-1 */
X
X	switch (outputBlockSize) {
X	case 10:	output[ 9] = input[ 9] ^ B02;
X	case  9:	output[ 8] = input[ 8] ^ B03;
X	case  8:	output[ 7] = input[ 7] ^ B04;
X	case  7:	output[ 6] = input[ 6] ^ B05;
X	case  6:	output[ 5] = input[ 5] ^ B06;
X	case  5:	output[ 4] = input[ 4] ^ B07;
X	case  4:	output[ 3] = input[ 3] ^ B08;
X	case  3:	output[ 2] = input[ 2] ^ B09;
X	case  2:	output[ 1] = input[ 1] ^ B10;
X	case  1:	output[ 0] = input[ 0] ^ B11;
X			break;
X	default: ErrAbort("Bad output block size");
X	};
X};
X
X
X/*
X * Snefru256 is a more efficient and specialized version of SnefruBlock.
X * It accepts an input of 8 32-bit words and produces an output of
X * outputBlockSize 32-bit words.  The output size cannot be bigger
X * than 6 32-bit words, or a serious degradation in security will occur.
X */
Xvoid
XSnefru256 (output, outputBlockSize, input, inputBlockSize, securityLevel)
X	word32	output[];
X	int	outputBlockSize;
X	word32	input[SNEFRU256_INPUT_BLOCK_SIZE];
X	int	inputBlockSize;
X	int	securityLevel;
X{
X	static int shiftTable[4] = {16, 8, 16, 24};
X	/* the array of data being hashed  */
X	word32	SBE;	/* just a temporary */
X	int     shift, leftShift;
X	int     index;
X	int     byteInWord;
X	word32	*SBox0;
X	word32	*SBox1;
X	word32	B00,B01,B02,B03,B04,B05,B06,B07;
X
X	/* initialize the block to be hashed from the input  */
X	B00 = input[0];
X	B01 = input[1];
X	B02 = input[2];
X	B03 = input[3];
X	B04 = 0;
X	B05 = 0;
X	B06 = 0;
X	B07 = 0;
X	switch (inputBlockSize) {
X	case 8:	B07 = input[7];
X	case 7:	B06 = input[6];
X	case 6:	B05 = input[5];
X	case 5:	B04 = input[4];
X		break;
X	default:	ErrAbort("bad input size to snefru256");
X	};
X
X
X	for (index = 0; index < securityLevel; index++) {
X		SBox0 = standardSBoxes[2*index+0];
X		SBox1 = standardSBoxes[2*index+1];
X		for (byteInWord = 0; byteInWord < 4; byteInWord++) {
X			round512(B07,B00,B01,SBox0);
X			round512(B00,B01,B02,SBox0);
X			round512(B01,B02,B03,SBox1);
X			round512(B02,B03,B04,SBox1);
X			round512(B03,B04,B05,SBox0);
X			round512(B04,B05,B06,SBox0);
X			round512(B05,B06,B07,SBox1);
X			round512(B06,B07,B00,SBox1);
X			/*
X			 * Rotate right all 32-bit words in the entire block
X			 * at once.
X			 */
X			shift = shiftTable[byteInWord];
X			leftShift = 32-shift;
X			rotate512(B00);
X			rotate512(B01);
X			rotate512(B02);
X			rotate512(B03);
X			rotate512(B04);
X			rotate512(B05);
X			rotate512(B06);
X			rotate512(B07);
X		};		/* end of byteInWord going from 0 to 3 */
X	};			/* end of index going from 0 to
X				 * securityLevel-1 */
X
X	switch (outputBlockSize) {
X	case  6:	output[ 5] = input[ 5] ^ B02;
X	case  5:	output[ 4] = input[ 4] ^ B03;
X	case  4:	output[ 3] = input[ 3] ^ B04;
X	case  3:	output[ 2] = input[ 2] ^ B05;
X	case  2:	output[ 1] = input[ 1] ^ B06;
X	case  1:	output[ 0] = input[ 0] ^ B07;
X			break;
X	default: ErrAbort("Bad output block size");
X	};
X};
X
X/*
X * Snefru128 is a more efficient and specialized version of SnefruBlock.
X * It accepts an input of 4 32-bit words and produces an output of
X * 32-bit words.  The output size cannot be bigger than 2 32-bit words,
X * or a serious degradation in security will occur.
X */
Xvoid
XSnefru128 (output, outputBlockSize, input, inputBlockSize, securityLevel)
X	word32	output[];
X	int	outputBlockSize;
X	word32	input[SNEFRU128_INPUT_BLOCK_SIZE];
X	int	inputBlockSize;
X	int	securityLevel;
X{
X	static int shiftTable[4] = {16, 8, 16, 24};
X	/* the array of data being hashed  */
X	word32	SBE;	/* just a temporary */
X	int     shift, leftShift;
X	int     index;
X	int     byteInWord;
X	word32	*SBox0;
X	word32	*SBox1;
X	word32	B00,B01,B02,B03;
X
X	/* initialize the block to be hashed from the input  */
X	B00 = 0;
X	B01 = 0;
X	B02 = 0;
X	B03 = 0;
X	switch (inputBlockSize) {
X	case 4:	B03 = input[3];
X	case 3:	B02 = input[2];
X	case 2:	B01 = input[1];
X	case 1:	B00 = input[0];
X		break;
X	default:	ErrAbort("bad input size to snefru128");
X	};
X
X
X	for (index = 0; index < securityLevel; index++) {
X		SBox0 = standardSBoxes[2*index+0];
X		SBox1 = standardSBoxes[2*index+1];
X		for (byteInWord = 0; byteInWord < 4; byteInWord++) {
X			round512(B03,B00,B01,SBox0);
X			round512(B00,B01,B02,SBox0);
X			round512(B01,B02,B03,SBox1);
X			round512(B02,B03,B00,SBox1);
X			/*
X			 * Rotate right all 32-bit words in the entire block
X			 * at once.
X			 */
X			shift = shiftTable[byteInWord];
X			leftShift = 32-shift;
X			rotate512(B00);
X			rotate512(B01);
X			rotate512(B02);
X			rotate512(B03);
X		};		/* end of byteInWord going from 0 to 3 */
X	};			/* end of index going from 0 to
X				 * securityLevel-1 */
X
X	switch (outputBlockSize) {
X	case  2:	output[ 1] = input[ 1] ^ B02;
X	case  1:	output[ 0] = input[ 0] ^ B03;
X			break;
X	default: ErrAbort("Bad output block size");
X	};
X};
X
X/*
X * HashAny is just a switching routine.  It calls the appropriate
X * hash function
X */
Xvoid    HashAny (output, outputBlockSize, input, inputBlockSize, hashMethod)
X	word32 output[/* outputBlockSize */];
X	int outputBlockSize;
X	word32 input[/* inputBlockSize */];
X	int     inputBlockSize;
X	int     hashMethod;
X{
X#if DEBUG_SNEFRU
X	/* Yes, dimension testOutput with the max INPUT size --
X	 * the input block size is guaranteed to be larger, and
X	 * sometimes someone pushes the output size...
X	 */
X	word32	testOutput[MAX_INPUT_BLOCK_SIZE];
X	int	i;
X#endif
X
X	static int	flag = 0;
X
X	switch ( hashMethod ) {
X		case MD4_METHOD:
X			Md4Block(output, outputBlockSize,
X				input, inputBlockSize);
X			return;
X		case SNEFRU3_METHOD:
X		case SNEFRU4_METHOD:
X			switch (inputBlockSize) {
X			default: {
X				if (flag == 0) {
X					flag = 1;
X					printf(
X		"Efficiency warning: using SnefruBlock (slow routine)\n");
X				};
X				SnefruBlock(output, outputBlockSize,
X				input, inputBlockSize, hashMethod);
X				return;
X				};
X			case  1:
X			case  2:
X			case  3:
X			case  4:
X
X					Snefru128(output, outputBlockSize,
X					input, inputBlockSize, hashMethod);
X					break;
X			case  5:
X			case  6:
X			case  7:
X			case  8:
X
X					Snefru256(output, outputBlockSize,
X					input, inputBlockSize, hashMethod);
X					break;
X
X			case   9:
X			case  10:
X			case  11:
X			case  12:
X
X					Snefru384(output, outputBlockSize,
X					input, inputBlockSize, hashMethod);
X					break;
X			case 13:
X			case 14:
X			case 15:
X			case 16:
X
X					Snefru512(output, outputBlockSize,
X					input, inputBlockSize, hashMethod);
X					break;
X				};
X/* Testing code -- if you want to verify the faster implementations
X * of Snefru put this code back in place.  It's painfully slow....
X */
X#if DEBUG_SNEFRU
X	SnefruBlock(testOutput, outputBlockSize,
X		input, inputBlockSize, hashMethod);
X	for (i=0; i<outputBlockSize; i++)
X		if(testOutput[i] != output[i]) {
X			PrintIt("input =",input,   inputBlockSize);
X			PrintIt("output=",output, outputBlockSize);
X			PrintIt("testOutput=", testOutput, outputBlockSize);
X			ErrAbort("Bad Snefru hash");
X		};
X#endif
X			break;
X		default:
X			ErrAbort("Bad hash method specifier");
X		};
X}
X
X/*  The following routine is a variant of HashAny which expects
X    to generate more output bits than input bits.  That is,
X    outputBlockSize is larger than inputBlockSize.  It is used
X    to expand a small amount of random information into a large
X    amount of pseudo-random information.
X*/
Xvoid    HashExpand (
X	outputBlock, outputBlockSize,
X	inputBlock, inputBlockSize,
X	hashMethod)
Xword32 outputBlock[/* outputBlockSize */];
Xint outputBlockSize;
Xword32 inputBlock[/* inputBlockSize */];
Xint     inputBlockSize;
Xint     hashMethod;
X{
X	int i;
X	word32 tempBlock[MAX_INPUT_BLOCK_SIZE];
X	int tempOutputSize;
X	int tempInputSize;
X
X	if (inputBlockSize >= MAX_INPUT_BLOCK_SIZE)
X		ErrAbort("inputBlockSize too large in HashExpand");
X	Copy (&tempBlock[1], inputBlock, inputBlockSize);
X	for (i=inputBlockSize+1; i<MAX_INPUT_BLOCK_SIZE; i++)
X		tempBlock[i]=0;
X	switch ( hashMethod ) {
X		case MD4_METHOD:
X			tempInputSize  = 16;
X			tempOutputSize = 4;
X			break;
X		case SNEFRU3_METHOD:
X		case SNEFRU4_METHOD:
X			tempInputSize  = MAX_INPUT_BLOCK_SIZE;
X			tempOutputSize = MAX_INPUT_BLOCK_SIZE-2;
X			break;
X		default:
X			ErrAbort("Bad hash method specifier");
X		};
X	if (inputBlockSize >= tempInputSize)
X 				ErrAbort("input to HashExpand too large");
X	for(i=0; i < outputBlockSize; i += tempOutputSize)  {
X		if (tempOutputSize > outputBlockSize-i)
X			tempOutputSize = outputBlockSize-i;
X		tempBlock[0]=i;
X		HashAny(&outputBlock[i], tempOutputSize,
X			tempBlock, tempInputSize, hashMethod);
X		};
X}
X
X
X
X/*  internal diagnostics. Make sure the S-Boxes aren't
Xmessed up, that the one-way hash function is correct, etc. */
Xvoid DoSelfTest(testingLevel)
X	int	testingLevel;
X{
X	int     i;
X
X	if (testingLevel <= 0) return;
X	/* Test the standard S boxes to make sure they haven't been
X	   damaged.  */
X	/* Test to make sure each column is a permutation.  */
X	for (i = 0; i < MAX_SBOX_COUNT; i++) {
X		char    testArray[256];
X		int     testShift = 0;
X		int     j;
X
X		for (testShift = 0; testShift < 32; testShift += 8) {
X			for (j = 0; j < 256; j++)
X				testArray[j] = 0;
X			for (j = 0; j < 256; j++)
X				testArray[(standardSBoxes[i][j] >>
X					testShift) & 0xff]++;
X			for (j = 0; j < 256; j++)
X				if (testArray[j] != 1)
X					ErrAbort
X			("Table error -- the standard S box is corrupted");
X		};
X	};
X	/* Okay, the standard S-box hasn't been damaged  */
X
X
X
X	/* Now try hashing something.  */
X	{
X		word32 testInput[MAX_INPUT_BLOCK_SIZE];
X		word32 testOutput[OUTPUT_BLOCK_SIZE];
X		int     j;
X		int	k;
X
X
X		if (OUTPUT_BLOCK_SIZE != 8)
X			ErrAbort ("The output block size has changed, update the self-test");
X		if (MAX_INPUT_BLOCK_SIZE != 16)
X			ErrAbort ("The input block size has changed, update the self-test");
X		if (MAX_SBOX_COUNT != 8)
X			ErrAbort ("Wrong number of S boxes, update the self-test");
X
X		for (i = 0; i < MAX_INPUT_BLOCK_SIZE; i++)
X			testInput[i] = 0;	/* zero the input */
X		k = 0;  /*  zero the pointer into the input buffer */
X		for (i = 0; i < 50; i++) {
X			SnefruBlock (testOutput, 8, testInput,16, 4);
X			/*	Copy the output into a new slot in the input buffer */
X			for (j = 0; j < OUTPUT_BLOCK_SIZE; j++)
X				testInput[k+j] = testOutput[j];
X			k += OUTPUT_BLOCK_SIZE;
X				/*	reset pointer into input buffer
X					if it might overflow next time */
X			if ( (k+OUTPUT_BLOCK_SIZE) > MAX_INPUT_BLOCK_SIZE) k=0;
X		};
X		if (	(testOutput[0] != 0x754D12FBL)	||
X			(testOutput[1] != 0xA04197D2L)	||
X			(testOutput[2] != 0xE92A9C7EL)	||
X			(testOutput[3] != 0x4298FF88L)	||
X			(testOutput[4] != 0xFCA820CFL)	||
X			(testOutput[5] != 0x344FDDE6L)	||
X			(testOutput[6] != 0x424DD3CAL)	||
X			(testOutput[7] != 0x135EFF62L)  )
X			ErrAbort ("Test hash of 64 bytes of 0 failed");
X	};
X	/* Okay, we can hash at least 50  64-byte values correctly.  */
X}
X
X
X/*
X * The following routine accepts, as input, a file name.
X * The contents of the file are hashed, and the hash result
X * is put into "hashValue".
X */
Xvoid
XSnefruHashFile (inputFile, hashValue, hashValueSize, securityLevel)
X	FILE	*inputFile;
X	word32	hashValue[];
X	int	hashValueSize;
X	int	securityLevel;
X{	int     i;
X	word32 hash[SNEFRU_INPUT_BLOCK_SIZE];
X	int	chunkSize;
X	word32 bitCount[2];	/* the 64-bit count of the number of
X					 * bits in the input */
X	long int byteCount;	/* the count of the number of bytes we just
X				 * read */
X
X	if (hashValueSize >= SNEFRU_INPUT_BLOCK_SIZE)
X		ErrAbort("hashValueSize >= SNEFRU_INPUT_BLOCK_SIZE");
X	bitCount[0] = 0;
X	bitCount[1] = 0;
X	for (i = 0; i < SNEFRU_INPUT_BLOCK_SIZE; i++)
X		hash[i] = 0;	/* initialize hash  */
X	/*
X	 * Hash each chunk in the input and keep the result in hash.
X	 * Note that the first 16 (32) bytes of hash holds the output
X	 * of the previous hash
X	 * computation done during the previous iteration of the loop
X	 */
X	chunkSize = SNEFRU_INPUT_BLOCK_SIZE - hashValueSize;
X	do {
X		/* Get the next chunk */
X		byteCount = ReadChunk (inputFile, &hash[hashValueSize],
X			chunkSize);
X		Increment64BitCounter (bitCount, 8*byteCount);
X		/* hash in the block we just read  */
X		if (byteCount > 0)
X			Snefru512 (hash, hashValueSize,
X				hash, SNEFRU_INPUT_BLOCK_SIZE, securityLevel);
X	} while (byteCount > 0);  /* end of while */
X
X	/*
X	 * Put the 64-bit bit-count into the final 64-bits of the block about
X	 * to be hashed
X	 */
X	hash[SNEFRU_INPUT_BLOCK_SIZE - 2] = bitCount[0];/* upper 32 bits of
X							 * count */
X	hash[SNEFRU_INPUT_BLOCK_SIZE - 1] = bitCount[1];/* lower 32 bits of
X							 * count */
X	/* Final hash down.  */
X	Snefru512 (hashValue, hashValueSize,
X			hash, SNEFRU_INPUT_BLOCK_SIZE, securityLevel);
X}
X
END_OF_FILE
if test 22749 -ne `wc -c <'h.c'`; then
    echo shar: \"'h.c'\" unpacked with wrong size!
fi
# end of 'h.c'
fi
if test -f 'makepublickey.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makepublickey.1'\"
else
echo shar: Extracting \"'makepublickey.1'\" \(5145 characters\)
sed "s/^X//" >'makepublickey.1' <<'END_OF_FILE'
X.TH "MAKEPUBLICKEY" 1 "May 8, 1990" "Hash Signatures"
X.SH NAME
Xmakepublickey - create a public checking key
X.SH FOR EXPERIMENTAL USE ONLY
X
X.SH SYNOPSIS
Xmakepublickey [ -sN ] [ -pN ] [ -nN ] [ -bN ] [ -hMethod ] [ -dDir ] userKey userName
X.SH DESCRIPTION
X.B Makepublickey
Xcreates a public checking key from the given user key and
Xa "randomly" generated machine key.  The
Xsecret signing key actually used to generate signatures
Xis derived by combining
Xboth the user key and the machine key.  In this way, if
Xthe user selects a poor key, the machine key will still
Xprovide good security.  If, on the other hand, a hacker
Xpenetrates the file system and reads the machine key, the
Xuser key remains unknown.  Only if both the user key and
Xthe machine key are compromised will the secret key be
Xcompromised.
X
XThe computed public checking key is put in the public
Xdirectory, and associated with the given userName.
XThe randomly generated machine key is put into the private
Xdirectory under the user's login id,
Xwith access by anyone other than the user denied.
XAn attempt to create a new public key when the user already has an existing
Xpublic key is an error.  If the user wishes to change keys, it is first
Xnecessary to destroy the existing machine key with "destroyoldkey".
X
X.SH OPTIONS
XThe following options can be ignored by the first time user.  Simply
Xusing the default options should produce satisfactory results.
X
X-sN  The security size is set to N.  Default is 2 (64 bits of security).  Greater security can be provided by setting this parameter to 3 (96 bits of security) or 4 (128 bits of security).
X
X-pN  The parameter size is set to N.  Default is 2 (64-bit parameters).  Increasing the parameter size does not significantly improve security.
X
X-nN  The size of internal sub-trees is set to N, where N must be a power
Xof 2.  Default is 32.  Influences signature size and signing/checking time.  Does not influence security.
X
X-bN  The number of bits per verifier is set to N.  Default is 4.
XDon't ask what it does.  Influences signature size and signing/checking time.  Does not influence security.
X
X-hMethod  The one-way hash function method is set as specified.
XOptions in the current implementation are:
Xmd4, snefru3, or snefru4.  These correspond to the
XRSA Data Security, Inc. MD4 Message Digest Algorithm;
Xthe three-pass version of Snefru, and the four-pass
Xversion of Snefru respectively.  Affects signing/checking time and security.
X
X-dDir  The directory into which the generated public key is placed is changed to Dir.
X
X.PP
X.SH EXAMPLES
Xmakepublickey XYZZY "Joe User"
X.PP
XCreates a public key and puts it into the default public key directory.
XAlso creates a random machine key and puts it into the
Xdefault private directory.  The actual "secret signing key" is
Xgenerated by combining the machine key and the user key.
X.PP
Xmakepublickey -dlocalDir -hmd4 XYZZY "M. Mouse"
X.PP
XCreates a public key and puts it into the local directory "localDir"
X(which must already exist).
XThis is useful when the standard public directory is read only
Xand public keys cannot be entered into it by unauthorized users.
XAlso creates a random machine key and puts it into the private directory.
XAlso specifies that MD4 is to be used as the one-way hash function.
XThus, the security of signed messages rests on the security of MD4,
Xand not on the security of any other one-way hash function.
XThis allows the user to specify whatever one-way hash function
Xthey feel is most suited for their particular application.
X(The default hash algorithm is subject to change without notice.
XIf you want a particular hashing algorithm, specify it.  If you
Xaren't sure what you want, just use the default).
X.SH FILES
X"makepublickey" expects to put the created public checking key into the public directory:
X/net/palain/rouge/pubdir.  It creates two copies of the
Xmachine key in the two directories (on two distinct disk drives):
X/net/palain/rouge/privdir and
X/net/palain/jaune/privdir.  It also initializes
Xinformation in the auxilliary directory:
X/net/palain/rouge/auxdir.
X.SH BUGS
XThe "userName" supplied by the user is not checked for authenticity.
XThe "check" program prints out both the userName and
Xthe user id of the user who
Xcreated the public key.  The user id is verified (to the extent
Xthat Unix can verify any user...)
XThe "userName" is not verified at the present time.
XWhile the user is "supposed" to enter his full name,
Xin fact any string can be entered, including a false
Xor misleading name (this IS an experimental system!)
XA more secure approach would be for a system
Xadministrator to verify the name
X(and other information) provided by the user
Xbefore adding that information to
Xthe public directory.  Only the authorized system
Xadministrator would be able to update or change the
Xinformation in the public directory, thus insuring its
Xcorrectness.
X
XA second bug is that the secret key is echoed on the command line,
Xrather than being entered from the terminal with echoing turned off.
X.SH "SEE ALSO"
Xcheck(1) sign(1) destroyoldkey(1) dumpsig(1) recoverauxinfo(1)
X.SH AUTHOR
XRalph C. Merkle
XCopyright (C) 1990 Xerox Corporation
XAll Rights Reserved
END_OF_FILE
if test 5145 -ne `wc -c <'makepublickey.1'`; then
    echo shar: \"'makepublickey.1'\" unpacked with wrong size!
fi
# end of 'makepublickey.1'
fi
if test -f 'md4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md4.c'\"
else
echo shar: Extracting \"'md4.c'\" \(11612 characters\)
sed "s/^X//" >'md4.c' <<'END_OF_FILE'
X
X/* The following notices are copied from the original release
X * of MD4 made available from Ron Rivest from MIT
X */
X/*
X___________________________________________________________________
XLicense to copy and use this document and the software described
Xherein is granted provided it is identified as the "RSA Data
XSecurity, Inc. MD4 Message Digest Algorithm" in all materials
Xmentioning or referencing this software, function, or document.
X
XLicense is also granted to make derivative works provided that such
Xworks are identified as "derived from the RSA Data Security, Inc. MD4
XMessage Digest Algorithm" in all material mentioning or referencing
Xthe derived work.
X
XRSA Data Security, Inc. makes no representations concerning the
Xmerchantability of this algorithm or software or their suitability
Xfor any specific purpose.  It is provided "as is" without express or
Ximplied warranty of any kind.
X
XThese notices must be retained in any copies of any part of this
Xdocumentation and/or software.
X___________________________________________________________________
X
X * XEROX GRANTS NO DIFFERENT OR ADDITIONAL RIGHTS TO USE THE
X * MODIFIED VERSION OF MD4 CONTAINED HEREIN.
X */
X
X/*
X * Various minor modifications (which should not change
X * the hash value computed) made 90.03.28 by Ralph C. Merkle
X */
Xtypedef	unsigned long int	word32;
Xvoid ErrAbort ();
X/*
X * The following routine converts a byte array to an array of word32.
X * This routine is intended for use with MD4, which defines
X * byte-ordering in the little endian or VAX style.  This routine
X * should work on almost any machine.  Non-portable routines should
X * be significantly faster.
X * Added 90.03.29 by Ralph C. Merkle.
X */
Xvoid 
XMD4ConvertBytes (buffer, wordBuffer, wordCount)
X	char    buffer[];	/*  input buffer */
X	word32 wordBuffer[];	/*  output buffer */
X	int     wordCount;
X{
X	int     i;
X	word32 t0, t1, t2, t3;
X
X	for (i = 0; i < wordCount; i++) {
X		t0 = buffer[4 * i + 3];
X		t1 = buffer[4 * i + 2];
X		t2 = buffer[4 * i + 1];
X		t3 = buffer[4 * i + 0];
X		t0 &= 0xff;
X		t1 &= 0xff;
X		t2 &= 0xff;
X		t3 &= 0xff;
X		wordBuffer[i] = (t0 << 24) | (t1 << 16) | (t2 << 8) | t3;
X	};
X}
X
X/* 
X** **************************************************************************
X** md4.c -- Implementation of MD4 Message Digest Algorithm                 **
X** Updated: 2/16/90 by Ronald L. Rivest                                    **
X** (C) 1990 RSA Data Security, Inc.                                        **
X** **************************************************************************
X*/
X
X/* 
X** To use MD4:
X**   -- Include md4.h in your program
X**   -- Declare an MDstruct MD to hold the state of the digest computation.
X**   -- Initialize MD using MDbegin(&MD)
X**   -- For each full block (64 bytes) X you wish to process, call
X**          MDupdate(&MD,X,512)
X**      (512 is the number of bits in a full block.)
X**   -- For the last block (less than 64 bytes) you wish to process,
X**          MDupdate(&MD,X,n)
X**      where n is the number of bits in the partial block. A partial
X**      block terminates the computation, so every MD computation should
X**      terminate by processing a partial block, even if it has n = 0.
X**   -- The message digest is available in MD.buffer[0] ... MD.buffer[3].
X**      (Least-significant byte of each word should be output first.)
X**   -- You can print out the digest using MDprint(&MD)
X*/
X
X/* Comment added 90.03.29 by RCM:  this implementation should be portable.
X * This will result in some loss of speed.  The "MDreverse" routine
X * provided by Rivest has been commented out, and the more portable
X * "MD4ConvertBytes" has been added.
X */
X
X/* Compile-time includes 
X*/
X#include <stdio.h>
X#include "md4.h"
X
X/* Compile-time declarations of MD4 ``magic constants''.
X*/
X#define I0  0x67452301L       /* Initial values for MD buffer */
X#define I1  0xefcdab89L
X#define I2  0x98badcfeL
X#define I3  0x10325476L
X#define C2  013240474631L     /* round 2 constant = sqrt(2) in octal */
X#define C3  015666365641L     /* round 3 constant = sqrt(3) in octal */
X/* C2 and C3 are from Knuth, The Art of Programming, Volume 2
X** (Seminumerical Algorithms), Second Edition (1981), Addison-Wesley.
X** Table 2, page 660.
X*/
X#define fs1  3               /* round 1 shift amounts */
X#define fs2  7   
X#define fs3 11  
X#define fs4 19  
X#define gs1  3               /* round 2 shift amounts */
X#define gs2  5   
X#define gs3  9   
X#define gs4 13  
X#define hs1  3               /* round 3 shift amounts */
X#define hs2  9 
X#define hs3 11 
X#define hs4 15
X
X
X/* Compile-time macro declarations for MD4.
X** Note: The ``rot'' operator uses the variable ``tmp''.
X** It assumes tmp is declared as word32, so that the >>
X** operator will shift in zeros rather than extending the sign bit.
X*/
X#define	f(X,Y,Z)             ((X&Y) | ((~X)&Z))
X#define	g(X,Y,Z)             ((X&Y) | (X&Z) | (Y&Z))
X#define h(X,Y,Z)             (X^Y^Z)
X#define rot(X,S)             (tmp=X,(tmp<<S) | (tmp>>(32-S)))
X#define ff(A,B,C,D,i,s)      A = rot((A + f(B,C,D) + X[i]),s)
X#define gg(A,B,C,D,i,s)      A = rot((A + g(B,C,D) + X[i] + C2),s)
X#define hh(A,B,C,D,i,s)      A = rot((A + h(B,C,D) + X[i] + C3),s)
X
X/* MDprint(MDp)
X** Print message digest buffer MDp as 32 hexadecimal digits.
X** Order is from low-order byte of buffer[0] to high-order byte of buffer[3].
X** Each byte is printed with high-order hexadecimal digit first.
X** This is a user-callable routine.
X*/
X/*
Xvoid 
XMDprint(MDp)
XMDptr MDp;
X{ int i,j;
X  for (i=0;i<4;i++)
X    for (j=0;j<32;j=j+8)
X      printf("%02x",(MDp->buffer[i]>>j) & 0xFFL);
X}
X*/
X/* MDbegin(MDp)
X** Initialize message digest buffer MDp. 
X** This is a user-callable routine.
X*/
Xvoid 
XMDbegin(MDp)
XMDptr MDp;
X{ int i;
X  MDp->buffer[0] = I0;  
X  MDp->buffer[1] = I1;  
X  MDp->buffer[2] = I2;  
X  MDp->buffer[3] = I3; 
X  for (i=0;i<8;i++) MDp->count[i] = 0;
X  MDp->done = 0;
X}
X
X/* MDreverse(X)
X** Reverse the byte-ordering of every int in X.
X** Assumes X is an array of 16 ints.
X** The macro revx reverses the byte-ordering of the next word of X.
X*/
X/*
X#define revx { t = (*X << 16) | (*X >> 16); \
X	       *X++ = ((t & 0xFF00FF00L) >> 8) | ((t & 0x00FF00FFL) << 8); }
XMDreverse(X)
Xword32 *X;
X{ register word32 t;
X  revx; revx; revx; revx; revx; revx; revx; revx;
X  revx; revx; revx; revx; revx; revx; revx; revx;
X}
X*/
X
X/* MDblock(MDp,X)
X** Update message digest buffer MDp->buffer using 16-word data block X.
X** Assumes all 16 words of X are full of data.
X** Does not update MDp->count.
X** This routine is not user-callable. 
X*/
Xstatic void
XMDblock(MDp,charX)
XMDptr MDp;
Xchar *charX;
X{
X  word32 X[16];
X  register word32 tmp, A, B, C, D;
X  MD4ConvertBytes(charX, X, 16);
X  A = MDp->buffer[0];
X  B = MDp->buffer[1];
X  C = MDp->buffer[2];
X  D = MDp->buffer[3];
X  /* Update the message digest buffer */
X  ff(A , B , C , D ,  0 , fs1); /* Round 1 */
X  ff(D , A , B , C ,  1 , fs2); 
X  ff(C , D , A , B ,  2 , fs3); 
X  ff(B , C , D , A ,  3 , fs4); 
X  ff(A , B , C , D ,  4 , fs1); 
X  ff(D , A , B , C ,  5 , fs2); 
X  ff(C , D , A , B ,  6 , fs3); 
X  ff(B , C , D , A ,  7 , fs4); 
X  ff(A , B , C , D ,  8 , fs1); 
X  ff(D , A , B , C ,  9 , fs2); 
X  ff(C , D , A , B , 10 , fs3); 
X  ff(B , C , D , A , 11 , fs4); 
X  ff(A , B , C , D , 12 , fs1); 
X  ff(D , A , B , C , 13 , fs2); 
X  ff(C , D , A , B , 14 , fs3); 
X  ff(B , C , D , A , 15 , fs4); 
X  gg(A , B , C , D ,  0 , gs1); /* Round 2 */
X  gg(D , A , B , C ,  4 , gs2); 
X  gg(C , D , A , B ,  8 , gs3); 
X  gg(B , C , D , A , 12 , gs4); 
X  gg(A , B , C , D ,  1 , gs1); 
X  gg(D , A , B , C ,  5 , gs2); 
X  gg(C , D , A , B ,  9 , gs3); 
X  gg(B , C , D , A , 13 , gs4); 
X  gg(A , B , C , D ,  2 , gs1); 
X  gg(D , A , B , C ,  6 , gs2); 
X  gg(C , D , A , B , 10 , gs3); 
X  gg(B , C , D , A , 14 , gs4); 
X  gg(A , B , C , D ,  3 , gs1); 
X  gg(D , A , B , C ,  7 , gs2); 
X  gg(C , D , A , B , 11 , gs3); 
X  gg(B , C , D , A , 15 , gs4);  
X  hh(A , B , C , D ,  0 , hs1); /* Round 3 */
X  hh(D , A , B , C ,  8 , hs2); 
X  hh(C , D , A , B ,  4 , hs3); 
X  hh(B , C , D , A , 12 , hs4); 
X  hh(A , B , C , D ,  2 , hs1); 
X  hh(D , A , B , C , 10 , hs2); 
X  hh(C , D , A , B ,  6 , hs3); 
X  hh(B , C , D , A , 14 , hs4); 
X  hh(A , B , C , D ,  1 , hs1); 
X  hh(D , A , B , C ,  9 , hs2); 
X  hh(C , D , A , B ,  5 , hs3); 
X  hh(B , C , D , A , 13 , hs4); 
X  hh(A , B , C , D ,  3 , hs1); 
X  hh(D , A , B , C , 11 , hs2); 
X  hh(C , D , A , B ,  7 , hs3); 
X  hh(B , C , D , A , 15 , hs4);
X  MDp->buffer[0] += A; 
X  MDp->buffer[1] += B;
X  MDp->buffer[2] += C;
X  MDp->buffer[3] += D; 
X}
X
X/* MDupdate(MDp,X,count)
X** Input: MDp -- an MDptr
X**        X -- a pointer to an array of unsigned characters.
X**        count -- the number of bits of X to use.
X**                 (if not a multiple of 8, uses high bits of last byte.)
X** Update MDp using the number of bits of X given by count.
X** This is the basic input routine for an MD4 user.
X** The routine completes the MD computation when count < 512, so
X** every MD computation should end with one call to MDupdate with a
X** count less than 512.  A call with count 0 will be ignored if the
X** MD has already been terminated (done != 0), so an extra call with count
X** 0 can be given as a ``courtesy close'' to force termination if desired.
X*/
Xvoid 
XMDupdate(MDp,X,count)
XMDptr MDp;
Xchar *X;
Xint count;
X{ word32 i, tmp, bit, byte, mask;
X  char XX[64];
X  unsigned char *p;
X  /* return with no error if this is a courtesy close with count
X  ** zero and MDp->done is true.
X  */
X  if (count == 0 && MDp->done) return;
X  /* check to see if MD is already done and report error */
X  if (MDp->done) {
X	fprintf(stderr, "\nError: MDupdate MD already done.");
X	exit(1);
X  }
X  /* Add count to MDp->count */
X  tmp = count;
X  p = MDp->count;
X  while (tmp)
X    { tmp += *p;
X      *p++ = tmp;
X      tmp = tmp >> 8;
X    }
X  /* Process data */
X  if (count == 512) 
X    { /* Full block of data to handle */
X      MDblock(MDp,X);
X    }
X  else if (count > 512) /* Check for count too large */
X    { fprintf(stderr,
X	"\nError: MDupdate called with illegal count value %d.",count);
X      exit(1);
X    }
X  else /* partial block -- must be last block so finish up */
X    { /* Find out how many bytes and residual bits there are */
X      byte = count >> 3;
X      bit =  count & 7;
X      /* Copy X into XX since we need to modify it */
X      for (i=0;i<=byte;i++)   XX[i] = X[i];
X      for (i=byte+1;i<64;i++) XX[i] = 0;
X      /* Add padding '1' bit and low-order zeros in last byte */
X      mask = 1 << (7 - bit);
X      XX[byte] = (XX[byte] | mask) & ~( mask - 1);
X      /* If room for bit count, finish up with this block */
X      if (byte <= 55)
X        { for (i=0;i<8;i++) XX[56+i] = MDp->count[i];
X          MDblock(MDp,XX);
X        }
X      else /* need to do two blocks to finish up */
X        { MDblock(MDp,XX);
X          for (i=0;i<56;i++) XX[i] = 0;
X          for (i=0;i<8;i++)  XX[56+i] = MDp->count[i];
X          MDblock(MDp,XX);
X        }
X      /* Set flag saying we're done with MD computation */
X      MDp->done = 1;
X    }
X}
X
X/* The following routine was adapted from the routine provided by
X * Ron Rivest. It computes the message digest for a specified file.
X */
XMd4HashFile(inputFile, hashValue, hashValueSize)
X	FILE	*inputFile;
X	word32	hashValue[];
X	int	hashValueSize;
X{	char	X[64];
X	MDstruct	MD;
X	int	b;
X
X	if (hashValueSize != 4)
X		ErrAbort("Only implemented 128-bit output for MD4");
X	MDbegin(&MD);
X	while ((b=fread(X,1,64,inputFile))!=0)
X		MDupdate(&MD,X,b*8);
X	if (ferror(inputFile))
X		ErrAbort("Can't read from input file");
X	MDupdate(&MD,X,0);
X	hashValue[0] = MD.buffer[0];
X	hashValue[1] = MD.buffer[1];
X	hashValue[2] = MD.buffer[2];
X	hashValue[3] = MD.buffer[3];
X}
X
END_OF_FILE
if test 11612 -ne `wc -c <'md4.c'`; then
    echo shar: \"'md4.c'\" unpacked with wrong size!
fi
# end of 'md4.c'
fi
if test -f 'md4.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md4.h'\"
else
echo shar: Extracting \"'md4.h'\" \(1771 characters\)
sed "s/^X//" >'md4.h' <<'END_OF_FILE'
X/* 
X** **************************************************************************
X** md4.h -- Header file for implementation of MD4 Message Digest Algorithm **
X** Updated: 2/13/90 by Ronald L. Rivest                                    **
X** (C) 1990 RSA Data Security, Inc.                                        **
X** **************************************************************************
X*/
X
X/* MDstruct is the data structure for a message digest computation.
X*/
Xtypedef struct {
X  unsigned int buffer[4];    /* Holds 4-word result of MD computation */
X  unsigned char count[8];    /* Number of bits processed so far */
X  unsigned int done;         /* Nonzero means MD computation finished */
X} MDstruct, *MDptr;
X
X/* MDbegin(MD)
X** Input: MD -- an MDptr
X** Initialize the MDstruct prepatory to doing a message digest computation.
X*/
Xextern void MDbegin();
X
X/* MDupdate(MD,X,count)
X** Input: MD -- an MDptr
X**        X -- a pointer to an array of unsigned characters.
X**        count -- the number of bits of X to use (an unsigned int).
X** Updates MD using the first ``count'' bits of X.
X** The array pointed to by X is not modified.
X** If count is not a multiple of 8, MDupdate uses high bits of last byte.
X** This is the basic input routine for a user.
X** The routine terminates the MD computation when count < 512, so
X** every MD computation should end with one call to MDupdate with a
X** count less than 512.  Zero is OK for a count.
X*/
Xextern void MDupdate();
X
X/* MDprint(MD)
X** Input: MD -- an MDptr
X** Prints message digest buffer MD as 32 hexadecimal digits.
X** Order is from low-order byte of buffer[0] to high-order byte of buffer[3].
X** Each byte is printed with high-order hexadecimal digit first.
X*/
Xextern void MDprint();      
X
X/* 
X** End of md4.h
X*/
END_OF_FILE
if test 1771 -ne `wc -c <'md4.h'`; then
    echo shar: \"'md4.h'\" unpacked with wrong size!
fi
# end of 'md4.h'
fi
if test -f 'md4Block.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md4Block.c'\"
else
echo shar: Extracting \"'md4Block.c'\" \(17169 characters\)
sed "s/^X//" >'md4Block.c' <<'END_OF_FILE'
X/*
X
XThis version of the algorithm has been modified by Ralph C. Merkle
X90.03.12.  Basically, various portions of the general-purpose hash
Xprovided by Ron Rivest and RSA Data Security have been removed,
Xleaving only the guts of the algorithm for use as a simple "block
Xhash" algorithm.
X
XThe following notice came from the version posted to sci.crypt
Xby RSA Data Security:
X
XLicense to copy and use this document and the software described
Xherein is granted provided it is identified as the "RSA Data
XSecurity, Inc. MD4 Message Digest Algorithm" in all materials
Xmentioning or referencing this software, function, or document.
X 
XLicense is also granted to make derivative works provided that such
Xworks are identified as "derived from the RSA Data Security, Inc. MD4
XMessage Digest Algorithm" in all material mentioning or referencing
Xthe derived work.
X 
XRSA Data Security, Inc. makes no representations concerning the
Xmerchantability of this algorithm or software or their suitability
Xfor any specific purpose.  It is provided "as is" without express or
Ximplied warranty of any kind.
X 
XThese notices must be retained in any copies of any part of this
Xdocumentation and/or software.
X------------------------------------------------------------------
X * XEROX GRANTS NO DIFFERENT OR ADDITIONAL RIGHTS TO USE THE
X * MODIFIED VERSION OF MD4 CONTAINED HEREIN.
X
X*/
X
X/*  The original comments, documentation, and explanations have
X    been retained, but they no longer are fully applicable to the
X    "stripped" version of md4 actually coded here.
X*/
X
X#if 0
X
X------------------------------------------------------------------------
X------------------------------------------------------------------------
X
X		 The MD4 Message Digest Algorithm
X		 --------------------------------
X			by Ronald L. Rivest
X	MIT Laboratory for Computer Science, Cambridge, Mass. 02139
X				and
X	RSA Data Security, Inc., Redwood City, California 94065
X		    (Version 2/17/90 -- Revised)
X
X
XAbstract:
X---------
X			    
XThis note describes the MD4 message digest algorithm.  The algorithm
Xtakes as input an input message of arbitrary length and produces as
Xoutput a 128-bit ``fingerprint'' or ``message digest'' of the input.
XIt is conjectured that it is computationally infeasible to produce two
Xmessages having the same message digest, or to produce any message
Xhaving a given prespecified target message digest.  The MD4 algorithm
Xis thus ideal for digital signature applications, where a large file
Xmust be ``compressed'' in a secure manner before being signed with the
XRSA public-key cryptosystem.
X
XThe MD4 algorithm is designed to be quite fast on 32-bit machines.  On
Xa SUN Sparc station, MD4 runs at 1,450,000 bytes/second.  On a DEC
XMicroVax II, MD4 runs at approximately 70,000 bytes/second.  On a 20MHz
X80286, MD4 runs at approximately 32,000 bytes/second.  In addition, the
XMD4 algorithm does not require any large substitution tables; the
Xalgorithm can be coded quite compactly.
X
XThe MD4 algorithm is being placed in the public domain for review and
Xpossible adoption as a standard.  
X
X(Note: The document supersedes an earlier draft.  The algorithm described
X       here is a slight modification of the one described in the draft.)
X
X
XI. Terminology and Notation
X---------------------------
X
XIn this note a ``word'' is a 32-bit quantity and a byte is an 8-byte
Xquantity.  A sequence of bits can be interpreted in a natural manner
Xas a sequence of bytes, where each consecutive group of 8 bits is
Xinterpreted as a byte with the high-order (most significant) bit of
Xeach byte listed first.  Similarly, a sequence of bytes can be
Xinterpreted as a sequence of 32-bit words, where each consecutive
Xgroup of 4 bytes is interpreted as a word with the low-order (least
Xsignificant) byte given first.
X
XLet x_i denote ``x sub i''.  If the subscript is an expression, we
Xsurround it in braces, as in x_{i+1}.  Similarly, we use ^ for
Xsuperscripts (exponentiation), so that x^i denotes x to the i-th
Xpower.
X
XLet the symbol ``+'' denote addition of words (i.e., modulo-2^32
Xaddition). Let X <<< s denote the 32-bit value obtained by circularly
Xshifting (rotating) X left by s bit positions.  Let not(X) denote the
Xbit-wise complement of X, and let X v Y denote the bit-wise OR of X
Xand Y.  Let X xor Y denote the bit-wise XOR of X and Y, and let XY
Xdenote the bit-wise AND of X and Y.
X
X
XII. MD4 Algorithm Description
X-----------------------------
X
XWe begin by supposing that we have a b-bit message as input, and
Xthat we wish to find its message digest.  Here b is an arbitrary
Xnonnegative integer; b may be zero, it need not be a multiple of 8,
Xand it may be arbitrarily large. We imagine the bits of the message
Xwritten down as follows:
X
X	m_0 m_1 ... m_{b-1} .
X
XThe following five steps are performed to compute the message digest of the
Xmessage.
X
X
XStep 1. Append padding bits
X---------------------------
X
XThe message is ``padded'' (extended) so that its length (in bits) is
Xcongruent to 448, modulo 512.  That is, the message is extended so
Xthat it is just 64 bits shy of being a multiple of 512 bits long.
XPadding is always performed, even if the length of the message is
Xalready congruent to 448, modulo 512 (in which case 512 bits of
Xpadding are added).
X
XPadding is performed as follows: a single ``1'' bit is appended to the
Xmessage, and then enough zero bits are appended so that the length in bits
Xof the padded message becomes congruent to 448, modulo 512.
X
X
XStep 2. Append length
X---------------------
X
XA 64-bit representation of b (the length of the message before the
Xpadding bits were added) is appended to the result of the previous
Xstep.  In the unlikely event that b is greater than 2^64, then only
Xthe low-order 64 bits of b are used.  (These bits are appended as two
X32-bit words and appended low-order word first in accordance with the
Xprevious conventions.)
X
XAt this point the resulting message (after padding with bits and with
Xb) has a length that is an exact multiple of 512 bits.  Equivalently,
Xthis message has a length that is an exact multiple of 16 (32-bit)
Xwords.  Let M[0 ... N-1] denote the words of the resulting message,
Xwhere N is a multiple of 16.
X
X
XStep 3. Initialize MD buffer
X----------------------------
X
XA 4-word buffer (A,B,C,D) is used to compute the message digest.  Here
Xeach of A,B,C,D are 32-bit registers.  These registers are initialized
Xto the following values (in hexadecimal, low-order bytes first):
X
X	word A:    01 23 45 67
X	word B:    89 ab cd ef
X	word C:    fe dc ba 98
X	word D:    76 54 32 10
X
X
XStep 4. Process message in 16-word blocks
X-----------------------------------------
X
XWe first define three auxiliary functions that each take as input
Xthree 32-bit words and produce as output one 32-bit word.
X
X	f(X,Y,Z)  =  XY v not(X)Z 
X	g(X,Y,Z)  =  XY v XZ v YZ 
X	h(X,Y,Z)  =  X xor Y xor Z 
X
XIn each bit position f acts as a conditional: if x then y else z.
X(The function f could have been defined using + instead of v since XY
Xand not(X)Z will never have 1's in the same bit position.)  In each
Xbit position g acts as a majority function: if at least two of x, y, z
Xare on, then g has a one in that bit position, else g has a zero. It
Xis interesting to note that if the bits of X, Y, and Z are independent
Xand unbiased, the each bit of f(X,Y,Z) will be independent and
Xunbiased, and similarly each bit of g(X,Y,Z) will be independent and
Xunbiased.  The function h is the bit-wise ``xor'' or ``parity'' function;
Xit has properties similar to those of f and g.
X
XDo the following:
X
XFor i = 0 to N/16-1 do	/* process each 16-word block */
X	For j = 0 to 15 do: /* copy block i into X */
X	  Set X[j] to M[i*16+j].
X	end /* of loop on j */
X	Save A as AA, B as BB, C as CC, and D as DD.
X
X	[Round 1]
X	  Let [A B C D i s] denote the operation
X		A = (A + f(B,C,D) + X[i]) <<< s  .
X	  Do the following 16 operations:
X		[A B C D 0 3] 
X		[D A B C 1 7] 
X		[C D A B 2 11] 
X		[B C D A 3 19] 
X		[A B C D 4 3] 
X		[D A B C 5 7] 
X		[C D A B 6 11] 
X		[B C D A 7 19] 
X		[A B C D 8 3] 
X		[D A B C 9 7] 
X		[C D A B 10 11] 
X		[B C D A 11 19] 
X		[A B C D 12 3] 
X		[D A B C 13 7] 
X		[C D A B 14 11] 
X		[B C D A 15 19] 
X
X	[Round 2]
X	  Let [A B C D i s] denote the operation
X	    	A = (A + g(B,C,D) + X[i] + 5A827999) <<< s .
X	  (The value 5A..99 is a hexadecimal 32-bit constant, written with
X	  the high-order digit first. This constant represents the square
X	  root of 2.  The octal value of this constant is 013240474631.
X          See Knuth, The Art of Programming, Volume 2
X	  (Seminumerical Algorithms), Second Edition (1981), Addison-Wesley.
X	  Table 2, page 660.)
X	  Do the following 16 operations:
X		[A B C D 0  3] 
X		[D A B C 4  5] 
X		[C D A B 8  9] 
X		[B C D A 12 13] 
X		[A B C D 1  3] 
X		[D A B C 5  5] 
X		[C D A B 9  9] 
X		[B C D A 13 13] 
X		[A B C D 2  3] 
X		[D A B C 6  5] 
X		[C D A B 10 9] 
X		[B C D A 14 13] 
X		[A B C D 3  3] 
X		[D A B C 7  5] 
X		[C D A B 11 9] 
X		[B C D A 15 13] 
X
X	[Round 3]
X	  Let [A B C D i s] denote the operation
X		A = (A + h(B,C,D) + X[i] + 6ED9EBA1) <<< s
X	  (The value 6E..A1 is a hexadecimal 32-bit constant, written with
X	  the high-order digit first. This constant represents the square
X	  root of 3.  The octal value of this constant is 015666365641.
X          See Knuth, The Art of Programming, Volume 2
X	  (Seminumerical Algorithms), Second Edition (1981), Addison-Wesley.
X	  Table 2, page 660.)
X	  Do the following 16 operations:
X		[A B C D 0  3] 
X		[D A B C 8  9] 
X		[C D A B 4  11] 
X		[B C D A 12 15] 
X		[A B C D 2  3] 
X		[D A B C 10 9] 
X		[C D A B 6  11] 
X		[B C D A 14 15] 
X		[A B C D 1  3] 
X		[D A B C 9  9] 
X		[C D A B 5  11] 
X		[B C D A 13 15] 
X		[A B C D 3  3] 
X		[D A B C 11 9] 
X		[C D A B 7  11] 
X		[B C D A 15 15] 
X
XThen perform the following additions:
X		A = A + AA
X		B = B + BB
X		C = C + CC
X		D = D + DD
X(That is, each of the four registers is incremented by the value it had
Xbefore this block was started.)
X
Xend /* of loop on i */
X
X
XStep 5. Output
X--------------
X
XThe message digest produced as output is A,B,C,D.
XThat is, we begin with the low-order byte of A, and end with the
Xhigh-order byte of D.
X
XThis completes the description of MD4.  A reference implementation in
XC is given in the Appendix.
X
X
XIII. Extensions
X---------------
X
XIf more than 128 bits of output are required, then the following
Xprocedure is recommended to obtain a 256-bit output.  (There is no
Xprovision made for obtaining more than 256 bits.)
X
XTwo copies of MD4 are run in parallel over the input.  The first copy
Xis standard as described above.  The second copy is modified as follows.
X
XThe initial state of the second copy is:
X	word A:    00 11 22 33
X	word B:    44 55 66 77
X	word C:    88 99 aa bb
X	word D:    cc dd ee ff
X
XThe magic constants in rounds 2 and 3 for the second copy of MD4 are
Xchanged from sqrt(2) and sqrt(3) to cuberoot(2) and cuberoot(3):
X				Octal		Hex
X	Round 2 constant	012050505746	50a28be6 
X	Round 3 constant	013423350444    5c4dd124
X
XFinally, after every 16-word block is processed (including the last
Xblock), the values of the A registers in the two copies are exchanged.
X
XThe final message digest is obtaining by appending the result of the
Xsecond copy of MD4 to the end of the result of the first copy of MD4.
X
X
XIV. Summary
X------------
X
XThe MD4 message digest algorithm is simple to implement, and provides
Xa ``fingerprint'' or message digest of a message of arbitrary length.
X
XIt is conjectured that the difficulty of coming up with two messages
Xhaving the same message digest is on the order of 2^64 operations, and
Xthat the difficulty of coming up with any message having a given
Xmessage digest is on the order of 2^128 operations.  The MD4 algorithm
Xhas been carefully scrutinized for weaknesses.  It is, however, a
Xrelatively new algorithm and further security analysis is of course
Xjustified, as is the case with any new proposal of this sort.  The
Xlevel of security provided by MD4 should be sufficient for
Ximplementing very high security hybrid digital signature schemes based
Xon MD4 and the RSA public-key cryptosystem.
X
XV. Acknowledgements
X-------------------
X
XI'd like to thank Don Coppersmith, Burt Kaliski, Ralph Merkle, and
XNoam Nisan for numerous helpful comments and suggestions.
X
X
XAPPENDIX. Reference Implementation
X----------------------------------
X
XThis appendix contains the following files:
X	md4.h		-- a header file for using the MD4 implementation
X	md4.c		-- the source code for the MD4 routines
X	md4driver.c	-- a sample ``user'' routine
X	session		-- sample results of running md4driver
X#endif
X
X
X/*
X**
X**  The following code has been modified (mostly by deleting parts
X The routine Md4Block
X**  is designed to hash a single block, and cuts out all
X**  the stuff required for hashing inputs of arbitrary lengths.
X**  This makes it much faster and simpler for this application.
X**
X**  Modified 90.03.12 by Ralph C. Merkle
X*/
X
X/*  Original header and credit to RSA Data Security and Ron Rivest  */
X/*
X** **************************************************************************
X** md4.c -- Implementation of MD4 Message Digest Algorithm                 **
X** Updated: 2/16/90 by Ronald L. Rivest                                    **
X** (C) 1990 RSA Data Security, Inc.                                        **
X** **************************************************************************
X*/
X 
X
X/* Compile-time declarations of MD4 ``magic constants''.
X*/
X#define I0  0x67452301       /* Initial values for MD buffer */
X#define I1  0xefcdab89
X#define I2  0x98badcfe
X#define I3  0x10325476
X#define C2  013240474631     /* round 2 constant = sqrt(2) in octal */
X#define C3  015666365641     /* round 3 constant = sqrt(3) in octal */
X/* C2 and C3 are from Knuth, The Art of Programming, Volume 2
X** (Seminumerical Algorithms), Second Edition (1981), Addison-Wesley.
X** Table 2, page 660.
X*/
X#define fs1  3               /* round 1 shift amounts */
X#define fs2  7   
X#define fs3 11  
X#define fs4 19  
X#define gs1  3               /* round 2 shift amounts */
X#define gs2  5   
X#define gs3  9   
X#define gs4 13  
X#define hs1  3               /* round 3 shift amounts */
X#define hs2  9 
X#define hs3 11 
X#define hs4 15
X
X
X/* Compile-time macro declarations for MD4.
X** Note: The ``rot'' operator uses the variable ``tmp''.
X** It assumes tmp is declared as unsigned, so that the >>
X** operator will shift in zeros rather than extending the sign bit.
X*/
X#define	f(X,Y,Z)             ((X&Y) | ((~X)&Z))
X#define	g(X,Y,Z)             ((X&Y) | (X&Z) | (Y&Z))
X#define h(X,Y,Z)             (X^Y^Z)
X#define rot(X,S)             (tmp=X,(tmp<<S) | (tmp>>(32-S)))
X#define ff(A,B,C,D,i,s)      A = rot((A + f(B,C,D) + X[i]),s)
X#define gg(A,B,C,D,i,s)      A = rot((A + g(B,C,D) + X[i] + C2),s)
X#define hh(A,B,C,D,i,s)      A = rot((A + h(B,C,D) + X[i] + C3),s)
X
Xtypedef unsigned long int word32;
X
Xextern void ErrAbort();
X
Xvoid 
XMd4Block(output, outputSize, input, inputSize)
Xword32 output[];
Xint outputSize;
Xword32 input[];
Xint inputSize;
X{
X  int i;
X  word32 X[16];
X  register word32 tmp, A, B, C, D;
X
X/*  copy input into X vector */
X  for(i=0; i<inputSize; i++)
X	X[i] = input[i];
X
X/*  zero out rest of X vector */
X  for(   ; i<16; i++)
X	X[i] = 0;
X
X  A = I0;
X  B = I1;
X  C = I2;
X  D = I3;
X  /* Update the message digest buffer */
X  ff(A , B , C , D ,  0 , fs1); /* Round 1 */
X  ff(D , A , B , C ,  1 , fs2); 
X  ff(C , D , A , B ,  2 , fs3); 
X  ff(B , C , D , A ,  3 , fs4); 
X  ff(A , B , C , D ,  4 , fs1); 
X  ff(D , A , B , C ,  5 , fs2); 
X  ff(C , D , A , B ,  6 , fs3); 
X  ff(B , C , D , A ,  7 , fs4); 
X  ff(A , B , C , D ,  8 , fs1); 
X  ff(D , A , B , C ,  9 , fs2); 
X  ff(C , D , A , B , 10 , fs3); 
X  ff(B , C , D , A , 11 , fs4); 
X  ff(A , B , C , D , 12 , fs1); 
X  ff(D , A , B , C , 13 , fs2); 
X  ff(C , D , A , B , 14 , fs3); 
X  ff(B , C , D , A , 15 , fs4); 
X  gg(A , B , C , D ,  0 , gs1); /* Round 2 */
X  gg(D , A , B , C ,  4 , gs2); 
X  gg(C , D , A , B ,  8 , gs3); 
X  gg(B , C , D , A , 12 , gs4); 
X  gg(A , B , C , D ,  1 , gs1); 
X  gg(D , A , B , C ,  5 , gs2); 
X  gg(C , D , A , B ,  9 , gs3); 
X  gg(B , C , D , A , 13 , gs4); 
X  gg(A , B , C , D ,  2 , gs1); 
X  gg(D , A , B , C ,  6 , gs2); 
X  gg(C , D , A , B , 10 , gs3); 
X  gg(B , C , D , A , 14 , gs4); 
X  gg(A , B , C , D ,  3 , gs1); 
X  gg(D , A , B , C ,  7 , gs2); 
X  gg(C , D , A , B , 11 , gs3); 
X  gg(B , C , D , A , 15 , gs4);  
X  hh(A , B , C , D ,  0 , hs1); /* Round 3 */
X  hh(D , A , B , C ,  8 , hs2); 
X  hh(C , D , A , B ,  4 , hs3); 
X  hh(B , C , D , A , 12 , hs4); 
X  hh(A , B , C , D ,  2 , hs1); 
X  hh(D , A , B , C , 10 , hs2); 
X  hh(C , D , A , B ,  6 , hs3); 
X  hh(B , C , D , A , 14 , hs4); 
X  hh(A , B , C , D ,  1 , hs1); 
X  hh(D , A , B , C ,  9 , hs2); 
X  hh(C , D , A , B ,  5 , hs3); 
X  hh(B , C , D , A , 13 , hs4); 
X  hh(A , B , C , D ,  3 , hs1); 
X  hh(D , A , B , C , 11 , hs2); 
X  hh(C , D , A , B ,  7 , hs3); 
X  hh(B , C , D , A , 15 , hs4);
X
X/*  dropped the increment, too.  For a single block, it doesn't
X**  make any difference.  RCM.
X*/
X
X  if(outputSize == 0) return;
X  output[0] = A;
X  if(outputSize == 1) return;
X  output[1] = B;
X  if(outputSize == 2) return;
X  output[2] = C;
X  if(outputSize == 3) return;
X  output[3] = D;
X  if(outputSize == 4) return;
X  ErrAbort("bad outputSize to md4");
X}
X
X
X
END_OF_FILE
if test 17169 -ne `wc -c <'md4Block.c'`; then
    echo shar: \"'md4Block.c'\" unpacked with wrong size!
fi
# end of 'md4Block.c'
fi
if test ! -d 'privDir' ; then
    echo shar: Creating directory \"'privDir'\"
    mkdir 'privDir'
fi
if test ! -d 'pubDir' ; then
    echo shar: Creating directory \"'pubDir'\"
    mkdir 'pubDir'
fi
if test -f 'recoverauxinfo.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'recoverauxinfo.1'\"
else
echo shar: Extracting \"'recoverauxinfo.1'\" \(1070 characters\)
sed "s/^X//" >'recoverauxinfo.1' <<'END_OF_FILE'
X.TH "RECOVERAUXINFO" 1 "May 8, 1990" "Hash Signatures"
X.SH NAME
Xrecoverauxinfo - recover the auxilliary signing information
X.SH FOR EXPERIMENTAL USE ONLY
X
X.SH SYNOPSIS
Xrecoverauxinfo key
X.SH DESCRIPTION
X.B Recoverauxinfo
Xrecovers the auxilliary signing information if it is damaged or destroyed.  The auxilliary signing information can be changed, revealed, etc. without loss of security.  If it is changed, signatures made with the changed auxilliary information will be invalid.  The auxilliary information can be regenerated at any time by using this command.
X.SH EXAMPLES
Xrecoverauxinfo secretKey
X.PP
XThe auxilliary information used by "sign" is regenerated.
X.SH FILES
X"recoverauxinfo" expects to put the auxilliary information in:
X/net/palain/rouge/auxdir.  It expects to find the machine key in the two directories (on two distinct disk drives):
X/net/palain/rouge/privdir and
X/net/palain/jaune/privdir.
X.SH "SEE ALSO"
Xcheck(1) sign(1) destroyoldkey(1) dumpsig(1) makepublickey(1)
X.SH AUTHOR
XRalph C. Merkle
XCopyright (C) 1990 Xerox Corporation
XAll Rights Reserved
END_OF_FILE
if test 1070 -ne `wc -c <'recoverauxinfo.1'`; then
    echo shar: \"'recoverauxinfo.1'\" unpacked with wrong size!
fi
# end of 'recoverauxinfo.1'
fi
if test -f 'sb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sb.c'\"
else
echo shar: Extracting \"'sb.c'\" \(30068 characters\)
sed "s/^X//" >'sb.c' <<'END_OF_FILE'
X/*
X * These are the standard S boxes used by the one-way hash function Snefru.
X * See the paper 'A Software One Way Hash Function', by Ralph C. Merkle,
X * for a more detailed explanation.
X * 
X * Version 2
X * 
X * NOTE:  This set of tables is different from Version 1. Version 2 is
X * recomended, Version 1 should not be used.
X *
X * March 1, 1990.  The S Boxes have been slightly re-formatted.
X * Constants have been suffixed with "L" to improve portability.
X * 
X * August 1, 1989
X * 
X * Copyright (c) Xerox Corporation 1989.  All rights reserved.
X *
X * The following notices apply to the S Boxes and related software
X * contained in this file.  They do not apply to the other files
X * included with this software.  Please refer to the appropriate
X * notices.
X *
X * License to  copy and use this software is granted provided that it is
X * identified as the 'Tables For the Xerox Secure Hash Function' in all
X * material mentioning or referencing this software.
X * 
X * License is also granted to make and use derivative works provided that such
X * works are identified as 'derived from the Tables For the Xerox Secure Hash
X * Function' in all material mentioning or referencing the derived work.
X * 
X * Xerox Corporation makes no representations concerning either the
X * merchantability of this software or the suitability of this software for
X * any particular purpose.  It is provided "as is" without express or implied
X * warranty of any kind.
X * 
X * 
X * These notices must be retained in any copies of any part of this software.
X * 
X * 
X * 
X * Implementor:  Ralph C. Merkle
X * 
X */
X
X#define MAX_SBOX_COUNT 8
Xunsigned long int standardSBoxes[MAX_SBOX_COUNT][256] = {
X
X	{	/* Start of S Box 0 */
X/*0*/	0x64F9001BL,0xFEDDCDF6L,0x7C8FF1E2L,0x11D71514L,0x8B8C18D3L,
X/*5*/	0xDDDF881EL,0x6EAB5056L,0x88CED8E1L,0x49148959L,0x69C56FD5L,
X/*10*/	0xB7994F03L,0x0FBCEE3EL,0x3C264940L,0x21557E58L,0xE14B3FC2L,
X/*15*/	0x2E5CF591L,0xDCEFF8CEL,0x092A1648L,0xBE812936L,0xFF7B0C6AL,
X/*20*/	0xD5251037L,0xAFA448F1L,0x7DAFC95AL,0x1EA69C3FL,0xA417ABE7L,
X/*25*/	0x5890E423L,0xB0CB70C0L,0xC85025F7L,0x244D97E3L,0x1FF3595FL,
X/*30*/	0xC4EC6396L,0x59181E17L,0xE635B477L,0x354E7DBFL,0x796F7753L,
X/*35*/	0x66EB52CCL,0x77C3F995L,0x32E3A927L,0x80CCAED6L,0x4E2BE89DL,
X/*40*/	0x375BBD28L,0xAD1A3D05L,0x2B1B42B3L,0x16C44C71L,0x4D54BFA8L,
X/*45*/	0xE57DDC7AL,0xEC6D8144L,0x5A71046BL,0xD8229650L,0x87FC8F24L,
X/*50*/	0xCBC60E09L,0xB6390366L,0xD9F76092L,0xD393A70BL,0x1D31A08AL,
X/*55*/	0x9CD971C9L,0x5C1EF445L,0x86FAB694L,0xFDB44165L,0x8EAAFCBEL,
X/*60*/	0x4BCAC6EBL,0xFB7A94E5L,0x5789D04EL,0xFA13CF35L,0x236B8DA9L,
X/*65*/	0x4133F000L,0x6224261CL,0xF412F23BL,0xE75E56A4L,0x30022116L,
X/*70*/	0xBAF17F1FL,0xD09872F9L,0xC1A3699CL,0xF1E802AAL,0x0DD145DCL,
X/*75*/	0x4FDCE093L,0x8D8412F0L,0x6CD0F376L,0x3DE6B73DL,0x84BA737FL,
X/*80*/	0xB43A30F2L,0x44569F69L,0x00E4EACAL,0xB58DE3B0L,0x959113C8L,
X/*85*/	0xD62EFEE9L,0x90861F83L,0xCED69874L,0x2F793CEEL,0xE8571C30L,
X/*90*/	0x483665D1L,0xAB07B031L,0x914C844FL,0x15BF3BE8L,0x2C3F2A9AL,
X/*95*/	0x9EB95FD4L,0x92E7472DL,0x2297CC5BL,0xEE5F2782L,0x5377B562L,
X/*100*/	0xDB8EBBCFL,0xF961DEDDL,0xC59B5C60L,0x1BD3910DL,0x26D206ADL,
X/*105*/	0xB28514D8L,0x5ECF6B52L,0x7FEA78BBL,0x504879ACL,0xED34A884L,
X/*110*/	0x36E51D3CL,0x1753741DL,0x8C47CAEDL,0x9D0A40EFL,0x3145E221L,
X/*115*/	0xDA27EB70L,0xDF730BA3L,0x183C8789L,0x739AC0A6L,0x9A58DFC6L,
X/*120*/	0x54B134C1L,0xAC3E242EL,0xCC493902L,0x7B2DDA99L,0x8F15BC01L,
X/*125*/	0x29FD38C7L,0x27D5318FL,0x604AAFF5L,0xF29C6818L,0xC38AA2ECL,
X/*130*/	0x1019D4C3L,0xA8FB936EL,0x20ED7B39L,0x0B686119L,0x89A0906FL,
X/*135*/	0x1CC7829EL,0x9952EF4BL,0x850E9E8CL,0xCD063A90L,0x67002F8EL,
X/*140*/	0xCFAC8CB7L,0xEAA24B11L,0x988B4E6CL,0x46F066DFL,0xCA7EEC08L,
X/*145*/	0xC7BBA664L,0x831D17BDL,0x63F575E6L,0x9764350EL,0x47870D42L,
X/*150*/	0x026CA4A2L,0x8167D587L,0x61B6ADABL,0xAA6564D2L,0x70DA237BL,
X/*155*/	0x25E1C74AL,0xA1C901A0L,0x0EB0A5DAL,0x7670F741L,0x51C05AEAL,
X/*160*/	0x933DFA32L,0x0759FF1AL,0x56010AB8L,0x5FDECB78L,0x3F32EDF8L,
X/*165*/	0xAEBEDBB9L,0x39F8326DL,0xD20858C5L,0x9B638BE4L,0xA572C80AL,
X/*170*/	0x28E0A19FL,0x432099FCL,0x3A37C3CDL,0xBF95C585L,0xB392C12AL,
X/*175*/	0x6AA707D7L,0x52F66A61L,0x12D483B1L,0x96435B5EL,0x3E75802BL,
X/*180*/	0x3BA52B33L,0xA99F51A5L,0xBDA1E157L,0x78C2E70CL,0xFCAE7CE0L,
X/*185*/	0xD1602267L,0x2AFFAC4DL,0x4A510947L,0x0AB2B83AL,0x7A04E579L,
X/*190*/	0x340DFD80L,0xB916E922L,0xE29D5E9BL,0xF5624AF4L,0x4CA9D9AFL,
X/*195*/	0x6BBD2CFEL,0xE3B7F620L,0xC2746E07L,0x5B42B9B6L,0xA06919BCL,
X/*200*/	0xF0F2C40FL,0x72217AB5L,0x14C19DF3L,0xF3802DAEL,0xE094BEB4L,
X/*205*/	0xA2101AFFL,0x0529575DL,0x55CDB27CL,0xA33BDDB2L,0x6528B37DL,
X/*210*/	0x740C05DBL,0xE96A62C4L,0x40782846L,0x6D30D706L,0xBBF48E2CL,
X/*215*/	0xBCE2D3DEL,0x049E37FAL,0x01B5E634L,0x2D886D8DL,0x7E5A2E7EL,
X/*220*/	0xD7412013L,0x06E90F97L,0xE45D3EBAL,0xB8AD3386L,0x13051B25L,
X/*225*/	0x0C035354L,0x71C89B75L,0xC638FBD0L,0x197F11A1L,0xEF0F08FBL,
X/*230*/	0xF8448651L,0x38409563L,0x452F4443L,0x5D464D55L,0x03D8764CL,
X/*235*/	0xB1B8D638L,0xA70BBA2FL,0x94B3D210L,0xEB6692A7L,0xD409C2D9L,
X/*240*/	0x68838526L,0xA6DB8A15L,0x751F6C98L,0xDE769A88L,0xC9EE4668L,
X/*245*/	0x1A82A373L,0x0896AA49L,0x42233681L,0xF62C55CBL,0x9F1C5404L,
X/*250*/	0xF74FB15CL,0xC06E4312L,0x6FFE5D72L,0x8AA8678BL,0x337CD129L,
X/*255*/	0x8211CEFDL
X	 /* End of S Box 0  */ },
X	{
X		/* Start of S Box 1 */
X/*0*/	0x074A1D09L,0x52A10E5AL,0x9275A3F8L,0x4B82506CL,0x37DF7E1BL,
X/*5*/	0x4C78B3C5L,0xCEFAB1DAL,0xF472267EL,0xB63045F6L,0xD66A1FC0L,
X/*10*/	0x400298E3L,0x27E60C94L,0x87D2F1B8L,0xDF9E56CCL,0x45CD1803L,
X/*15*/	0x1D35E098L,0xCCE7C736L,0x03483BF1L,0x1F7307D7L,0xC6E8F948L,
X/*20*/	0xE613C111L,0x3955C6FFL,0x1170ED7CL,0x8E95DA41L,0x99C31BF4L,
X/*25*/	0xA4DA8021L,0x7B5F94FBL,0xDD0DA51FL,0x6562AA77L,0x556BCB23L,
X/*30*/	0xDB1BACC6L,0x798040B9L,0xBFE5378FL,0x731D55E6L,0xDAA5BFEEL,
X/*35*/	0x389BBC60L,0x1B33FBA4L,0x9C567204L,0x36C26C68L,0x77EE9D69L,
X/*40*/	0x8AEB3E88L,0x2D50B5CEL,0x9579E790L,0x42B13CFCL,0x33FBD32BL,
X/*45*/	0xEE0503A7L,0xB5862824L,0x15E41EADL,0xC8412EF7L,0x9D441275L,
X/*50*/	0x2FCEC582L,0x5FF483B7L,0x8F3931DFL,0x2E5D2A7BL,0x49467BF9L,
X/*55*/	0x0653DEA9L,0x2684CE35L,0x7E655E5CL,0xF12771D8L,0xBB15CC67L,
X/*60*/	0xAB097CA1L,0x983DCF52L,0x10DDF026L,0x21267F57L,0x2C58F6B4L,
X/*65*/	0x31043265L,0x0BAB8C01L,0xD5492099L,0xACAAE619L,0x944CE54AL,
X/*70*/	0xF2D13D39L,0xADD3FC32L,0xCDA08A40L,0xE2B0D451L,0x9EFE08AEL,
X/*75*/	0xB9D50FD2L,0xEA5CD7FDL,0xC9A749DDL,0x13EA2253L,0x832DEBAAL,
X/*80*/	0x24BE640FL,0xE03E926AL,0x29E01CDEL,0x8BF59F18L,0x0F9D00B6L,
X/*85*/	0xE1238B46L,0x1E7D8E34L,0x93619ADBL,0x76B32F9FL,0xBD972CECL,
X/*90*/	0xE31FA976L,0xA68FBB10L,0xFB3BA49DL,0x8587C41DL,0xA5ADD1D0L,
X/*95*/	0xF3CF84BFL,0xD4E11150L,0xD9FFA6BCL,0xC3F6018CL,0xAEF10572L,
X/*100*/	0x74A64B2FL,0xE7DC9559L,0x2AAE35D5L,0x5B6F587FL,0xA9E353FEL,
X/*105*/	0xCA4FB674L,0x04BA24A8L,0xE5C6875FL,0xDCBC6266L,0x6BC5C03FL,
X/*110*/	0x661EEF02L,0xED740BABL,0x058E34E4L,0xB7E946CFL,0x88698125L,
X/*115*/	0x72EC48EDL,0xB11073A3L,0xA13485EBL,0xA2A2429CL,0xFA407547L,
X/*120*/	0x50B76713L,0x5418C37DL,0x96192DA5L,0x170BB04BL,0x518A021EL,
X/*125*/	0xB0AC13D1L,0x0963FA2AL,0x4A6E10E1L,0x58472BDCL,0xF7F8D962L,
X/*130*/	0x979139EAL,0x8D856538L,0xC0997042L,0x48324D7AL,0x447623CBL,
X/*135*/	0x8CBBE364L,0x6E0C6B0EL,0xD36D63B0L,0x3F244C84L,0x3542C971L,
X/*140*/	0x2B228DC1L,0xCB0325BBL,0xF8C0D6E9L,0xDE11066BL,0xA8649327L,
X/*145*/	0xFC31F83EL,0x7DD80406L,0xF916DD61L,0xD89F79D3L,0x615144C2L,
X/*150*/	0xEBB45D31L,0x28002958L,0x56890A37L,0xF05B3808L,0x123AE844L,
X/*155*/	0x86839E16L,0x914B0D83L,0xC506B43CL,0xCF3CBA5EL,0x7C60F5C9L,
X/*160*/	0x22DEB2A0L,0x5D9C2715L,0xC77BA0EFL,0x4F45360BL,0xC1017D8BL,
X/*165*/	0xE45ADC29L,0xA759909BL,0x412CD293L,0xD7D796B1L,0x00C8FF30L,
X/*170*/	0x23A34A80L,0x4EC15C91L,0x714E78B5L,0x47B9E42EL,0x78F3EA4DL,
X/*175*/	0x7F078F5BL,0x346C593AL,0xA3A87A1AL,0x9BCBFE12L,0x3D439963L,
X/*180*/	0xB2EF6D8EL,0xB8D46028L,0x6C2FD5CAL,0x62675256L,0x01F2A2F3L,
X/*185*/	0xBC96AE0AL,0x709A8920L,0xB4146E87L,0x6308B9E2L,0x64BDA7BAL,
X/*190*/	0xAFED6892L,0x6037F2A2L,0xF52969E0L,0x0ADB43A6L,0x82811400L,
X/*195*/	0x90D0BDF0L,0x19C9549EL,0x203F6A73L,0x1ACCAF4FL,0x89714E6DL,
X/*200*/	0x164D4705L,0x67665F07L,0xEC206170L,0x0C2182B2L,0xA02B9C81L,
X/*205*/	0x53289722L,0xF6A97686L,0x140E4179L,0x9F778849L,0x9A88E15DL,
X/*210*/	0x25CADB54L,0xD157F36FL,0x32A421C3L,0xB368E98AL,0x5A92CD0DL,
X/*215*/	0x757AA8D4L,0xC20AC278L,0x08B551C7L,0x849491E8L,0x4DC75AD6L,
X/*220*/	0x697C33BEL,0xBAF0CA33L,0x46125B4EL,0x59D677B3L,0x30D9C8F2L,
X/*225*/	0xD0AF860CL,0x1C7FD0FAL,0xFE0FF72CL,0x5C8D6F43L,0x57FDEC3BL,
X/*230*/	0x6AB6AD97L,0xD22ADF89L,0x18171785L,0x02BFE22DL,0x6DB80917L,
X/*235*/	0x80B216AFL,0xE85E4F9AL,0x7A1C306EL,0x6FC49BF5L,0x3AF7A11CL,
X/*240*/	0x81E215E7L,0x68363FCDL,0x3E9357C8L,0xEF52FD55L,0x3B8BAB4CL,
X/*245*/	0x3C8CF495L,0xBEFCEEBDL,0xFD25B714L,0xC498D83DL,0x0D2E1A8DL,
X/*250*/	0xE9F966ACL,0x0E387445L,0x435419E5L,0x5E7EBEC4L,0xAA90B8D9L,
X/*255*/	0xFF1A3A96L},
X	{
X		/* Start of S-box 2 */
X/*0*/	0x4A8FE4E3L,0xF27D99CDL,0xD04A40CAL,0xCB5FF194L,0x3668275AL,
X/*5*/	0xFF4816BEL,0xA78B394CL,0x4C6BE9DBL,0x4EEC38D2L,0x4296EC80L,
X/*10*/	0xCDCE96F8L,0x888C2F38L,0xE75508F5L,0x7B916414L,0x060AA14AL,
X/*15*/	0xA214F327L,0xBE608DAFL,0x1EBBDEC2L,0x61F98CE9L,0xE92156FEL,
X/*20*/	0x4F22D7A3L,0x3F76A8D9L,0x559A4B33L,0x38AD2959L,0xF3F17E9EL,
X/*25*/	0x85E1BA91L,0xE5EBA6FBL,0x73DCD48CL,0xF5C3FF78L,0x481B6058L,
X/*30*/	0x8A3297F7L,0x8F1F3BF4L,0x93785AB2L,0x477A4A5BL,0x6334EB5DL,
X/*35*/	0x6D251B2EL,0x74A9102DL,0x07E38FFAL,0x915C9C62L,0xCCC275EAL,
X/*40*/	0x6BE273ECL,0x3EBDDD70L,0xD895796CL,0xDC54A91BL,0xC9AFDF81L,
X/*45*/	0x23633F73L,0x275119B4L,0xB19F6B67L,0x50756E22L,0x2BB152E2L,
X/*50*/	0x76EA46A2L,0xA353E232L,0x2F596AD6L,0x0B1EDB0BL,0x02D3D9A4L,
X/*55*/	0x78B47843L,0x64893E90L,0x40F0CAADL,0xF68D3AD7L,0x46FD1707L,
X/*60*/	0x1C9C67EFL,0xB5E086DEL,0x96EE6CA6L,0x9AA34774L,0x1BA4F48AL,
X/*65*/	0x8D01ABFDL,0x183EE1F6L,0x5FF8AA7AL,0x17E4FAAEL,0x303983B0L,
X/*70*/	0x6C08668BL,0xD4AC4382L,0xE6C5849FL,0x92FEFB53L,0xC1CAC4CEL,
X/*75*/	0x43501388L,0x441118CFL,0xEC4FB308L,0x53A08E86L,0x9E0FE0C5L,
X/*80*/	0xF91C1525L,0xAC45BE05L,0xD7987CB5L,0x49BA1487L,0x57938940L,
X/*85*/	0xD5877648L,0xA958727FL,0x58DFE3C3L,0xF436CF77L,0x399E4D11L,
X/*90*/	0xF0A5BFA9L,0xEF61A33BL,0xA64CAC60L,0x04A8D0BAL,0x030DD572L,
X/*95*/	0xB83D320FL,0xCAB23045L,0xE366F2F0L,0x815D008DL,0xC897A43AL,
X/*100*/	0x1D352DF3L,0xB9CC571DL,0x8BF38744L,0x72209092L,0xEBA124EBL,
X/*105*/	0xFB99CE5EL,0x3BB94293L,0x28DA549CL,0xAAB8A228L,0xA4197785L,
X/*110*/	0x33C70296L,0x25F6259BL,0x5C85DA21L,0xDF15BDEEL,0x15B7C7E8L,
X/*115*/	0xE2ABEF75L,0xFCC19BC1L,0x417FF868L,0x14884434L,0x62825179L,
X/*120*/	0xC6D5C11CL,0x0E4705DCL,0x22700DE0L,0xD3D2AF18L,0x9BE822A0L,
X/*125*/	0x35B669F1L,0xC42BB55CL,0x0A801252L,0x115BF0FCL,0x3CD7D856L,
X/*130*/	0xB43F5F9DL,0xC2306516L,0xA1231C47L,0xF149207EL,0x5209A795L,
X/*135*/	0x34B3CCD8L,0x67AEFE54L,0x2C83924EL,0x6662CBACL,0x5EEDD161L,
X/*140*/	0x84E681AAL,0x5D57D26BL,0xFA465CC4L,0x7E3AC3A8L,0xBF7C0CC6L,
X/*145*/	0xE18A9AA1L,0xC32F0A6FL,0xB22CC00DL,0x3D280369L,0x994E554FL,
X/*150*/	0x68F480D3L,0xADCFF5E6L,0x3A8EB265L,0x83269831L,0xBD568A09L,
X/*155*/	0x4BC8AE6AL,0x69F56D2BL,0x0F17EAC8L,0x772EB6C7L,0x9F41343CL,
X/*160*/	0xAB1D0742L,0x826A6F50L,0xFEA2097CL,0x1912C283L,0xCE185899L,
X/*165*/	0xE4444839L,0x2D8635D5L,0x65D0B1FFL,0x865A7F17L,0x326D9FB1L,
X/*170*/	0x59E52820L,0x0090ADE1L,0x753C7149L,0x9DDD8B98L,0xA5A691DAL,
X/*175*/	0x0D0382BBL,0x8904C930L,0x086CB000L,0x6E69D3BDL,0x24D4E7A7L,
X/*180*/	0x05244FD0L,0x101A5E0CL,0x6A947DCBL,0xE840F77BL,0x7D0C5003L,
X/*185*/	0x7C370F1FL,0x805245EDL,0xE05E3D3FL,0x7906880EL,0xBABFCD35L,
X/*190*/	0x1A7EC697L,0x8C052324L,0x0C6EC8DFL,0xD129A589L,0xC7A75B02L,
X/*195*/	0x12D81DE7L,0xD9BE2A66L,0x1F4263ABL,0xDE73FDB6L,0x2A00680AL,
X/*200*/	0x56649E36L,0x3133ED55L,0x90FA0BF2L,0x2910A02AL,0x949D9D46L,
X/*205*/	0xA0D1DCDDL,0xCFC9B7D4L,0xD2677BE5L,0x95CB36B3L,0x13CD9410L,
X/*210*/	0xDBF73313L,0xB7C6E8C0L,0xF781414BL,0x510B016DL,0xB0DE1157L,
X/*215*/	0xD6B0F62CL,0xBB074ECCL,0x7F1395B7L,0xEE792CF9L,0xEA6FD63EL,
X/*220*/	0x5BD6938EL,0xAF02FC64L,0xDAB57AB8L,0x8EDB3784L,0x8716318FL,
X/*225*/	0x164D1A01L,0x26F26141L,0xB372E6B9L,0xF8FC2B06L,0x7AC00E04L,
X/*230*/	0x3727B89AL,0x97E9BCA5L,0x9C2A742FL,0xBC3B1F7DL,0x7165B471L,
X/*235*/	0x609B4C29L,0x20925351L,0x5AE72112L,0x454BE5D1L,0xC0FFB95FL,
X/*240*/	0xDD0EF919L,0x6F2D70C9L,0x0974C5BFL,0x98AA6263L,0x01D91E4DL,
X/*245*/	0x2184BB6EL,0x70C43C1EL,0x4D435915L,0xAE7B8523L,0xB6FB06BCL,
X/*250*/	0x5431EE76L,0xFDBC5D26L,0xED77493DL,0xC5712EE4L,0xA8380437L,
X/*255*/	0x2EEF261AL},
X	{
X		/* Start of S Box 3 */
X/*0*/	0x5A79392BL,0xB8AF32C2L,0x41F7720AL,0x833A61ECL,0x13DFEDACL,
X/*5*/	0xC4990BC4L,0xDC0F54BCL,0xFEDD5E88L,0x80DA1881L,0x4DEA1AFDL,
X/*10*/	0xFD402CC6L,0xAE67CC7AL,0xC5238525L,0x8EA01254L,0xB56B9BD5L,
X/*15*/	0x862FBD6DL,0xAC8575D3L,0x6FBA3714L,0xDA7EBF46L,0x59CD5238L,
X/*20*/	0x8AC9DBFEL,0x353729FCL,0xE497D7F2L,0xC3AB84E0L,0xF05A114BL,
X/*25*/	0x7B887A75L,0xEDC603DDL,0x5E6FE680L,0x2C84B399L,0x884EB1DAL,
X/*30*/	0x1CB8C8BFL,0xAA51098AL,0xC862231CL,0x8BAC2221L,0x21B387E5L,
X/*35*/	0x208A430DL,0x2A3F0F8BL,0xA5FF9CD2L,0x6012A2EAL,0x147A9EE7L,
X/*40*/	0xF62A501DL,0xB4B2E51AL,0x3EF3484CL,0xC0253C59L,0x2B82B536L,
X/*45*/	0x0AA9696BL,0xBE0C109BL,0xC70B7929L,0xCE3E8A19L,0x2F66950EL,
X/*50*/	0x459F1C2CL,0xE68FB93DL,0xA3C3FF3EL,0x62B45C62L,0x300991CBL,
X/*55*/	0x01914C57L,0x7F7BC06AL,0x182831F5L,0xE7B74BCAL,0xFA50F6D0L,
X/*60*/	0x523CAA61L,0xE3A7CF05L,0xE9E41311L,0x280A21D1L,0x6A4297E1L,
X/*65*/	0xF24DC67EL,0xFC3189E6L,0xB72BF34FL,0x4B1E67AFL,0x543402CEL,
X/*70*/	0x79A59867L,0x0648E02AL,0x00A3AC17L,0xC6208D35L,0x6E7F5F76L,
X/*75*/	0xA45BB4BEL,0xF168FA63L,0x3F4125F3L,0xF311406FL,0x02706565L,
X/*80*/	0xBFE58022L,0x0CFCFDD9L,0x0735A7F7L,0x8F049092L,0xD98EDC27L,
X/*85*/	0xF5C5D55CL,0xE0F201DBL,0x0DCAFC9AL,0x7727FB79L,0xAF43ABF4L,
X/*90*/	0x26E938C1L,0x401B26A6L,0x900720FAL,0x2752D97BL,0xCFF1D1B3L,
X/*95*/	0xA9D9E424L,0x42DB99ABL,0x6CF8BE5FL,0xE82CEBE3L,0x3AFB733BL,
X/*100*/	0x6B734EB6L,0x1036414AL,0x975F667CL,0x049D6377L,0xBA587C60L,
X/*105*/	0xB1D10483L,0xDE1AEFCCL,0x1129D055L,0x72051E91L,0x6946D623L,
X/*110*/	0xF9E86EA7L,0x48768C00L,0xB0166C93L,0x9956BBF0L,0x1F1F6D84L,
X/*115*/	0xFB15E18EL,0x033B495DL,0x56E3362EL,0x4F44C53CL,0x747CBA51L,
X/*120*/	0x89D37872L,0x5D9C331BL,0xD2EF9FA8L,0x254917F8L,0x1B106F47L,
X/*125*/	0x37D75553L,0xB3F053B0L,0x7DCCD8EFL,0xD30EB802L,0x5889F42DL,
X/*130*/	0x610206D7L,0x1A7D34A1L,0x92D87DD8L,0xE5F4A315L,0xD1CF0E71L,
X/*135*/	0xB22DFE45L,0xB901E8EBL,0x0FC0CE5EL,0x2EFA60C9L,0x2DE74290L,
X/*140*/	0x36D0C906L,0x381C70E4L,0x4C6DA5B5L,0x3D81A682L,0x7E381F34L,
X/*145*/	0x396C4F52L,0x95AD5901L,0x1DB50C5AL,0x29982E9EL,0x1557689FL,
X/*150*/	0x3471EE42L,0xD7E2F7C0L,0x8795A1E2L,0xBC324D8DL,0xE224C3C8L,
X/*155*/	0x12837E39L,0xCDEE3D74L,0x7AD2143FL,0x0E13D40CL,0x78BD4A68L,
X/*160*/	0xA2EB194DL,0xDB9451F9L,0x859B71DCL,0x5C4F5B89L,0xCA14A8A4L,
X/*165*/	0xEF92F003L,0x16741D98L,0x33AA4444L,0x9E967FBBL,0x092E3020L,
X/*170*/	0xD86A35B8L,0x8CC17B10L,0xE1BF08AEL,0x55693FC5L,0x7680AD13L,
X/*175*/	0x1E6546E8L,0x23B6E7B9L,0xEE77A4B2L,0x08ED0533L,0x44FD2895L,
X/*180*/	0xB6393B69L,0x05D6CACFL,0x9819B209L,0xECBBB72FL,0x9A75779CL,
X/*185*/	0xEAEC0749L,0x94A65AEEL,0xBDF52DC3L,0xD6A25D04L,0x82008E4EL,
X/*190*/	0xA6DE160FL,0x9B036AFBL,0x228B3A66L,0x5FB10A70L,0xCC338B58L,
X/*195*/	0x5378A9DFL,0xC908BCA9L,0x4959E25BL,0x46909A97L,0x66AE8F6EL,
X/*200*/	0xDD0683E9L,0x65F994B4L,0x6426CDA5L,0xC24B8840L,0x32539DA0L,
X/*205*/	0x63175650L,0xD0C815FFL,0x50CBC41EL,0xF7C774A3L,0x31B0C231L,
X/*210*/	0x8D0D8116L,0x24BEF16CL,0xD555D256L,0xDF47EA8CL,0x6D21ECCDL,
X/*215*/	0xA887A012L,0x84542AEDL,0xA7B9C1BDL,0x914C1BB1L,0xA0D5B67DL,
X/*220*/	0x438CE937L,0x7030F873L,0x71F6B0C7L,0x574576BAL,0xF8BC4541L,
X/*225*/	0x9C61D348L,0x1960579DL,0x17C4DAADL,0x96A4CB0BL,0xC193F2F6L,
X/*230*/	0x756EAFA2L,0x7C1D2F94L,0xF4FE2B43L,0xCB86E33AL,0xEBD4C728L,
X/*235*/	0x9D18AE64L,0x9FE13E30L,0x3CE0F5DEL,0xABA1F985L,0xADDC2718L,
X/*240*/	0x68CE6278L,0xD45E241FL,0xA15C82B7L,0x3B2293D4L,0x739EDD32L,
X/*245*/	0x674A6BF1L,0x5B5D587FL,0x4772DEAAL,0x4A63968FL,0x0BE68686L,
X/*250*/	0x513D6426L,0x939A4787L,0xBBA89296L,0x4EC20007L,0x818D0D08L,
X/*255*/	0xFF64DFD6L},
X	{
X		/* Start of S Box 4 */
X/*0*/	0xCB2297CBL,0xDB48A144L,0xA16CBE4BL,0xBBEA1D6CL,0x5AF6B6B7L,
X/*5*/	0x8A8110B6L,0xF9236EF9L,0xC98F83E6L,0x0F9C65B8L,0x252D4A89L,
X/*10*/	0xA497F068L,0xA5D7ED2DL,0x94C22845L,0x9DA1C8C4L,0xE27C2E2EL,
X/*15*/	0x6E8BA2B4L,0xC3DD17FBL,0x498CD482L,0x0DFE6A9FL,0xB0705829L,
X/*20*/	0x9A1E6DC1L,0xF829717CL,0x07BB8E3AL,0xDA3C0B02L,0x1AF82FC7L,
X/*25*/	0x73B70955L,0x7A04379CL,0x5EE20A28L,0x83712AE5L,0xF4C47C6DL,
X/*30*/	0xDF72BA56L,0xD794858DL,0x8C0CF709L,0x18F0F390L,0xB6C69B35L,
X/*35*/	0xBF2F01DBL,0x2FA74DCAL,0xD0CD9127L,0xBDE66CECL,0x3DEEBD46L,
X/*40*/	0x57C88FC3L,0xCEE1406FL,0x0066385AL,0xF3C3444FL,0x3A79D5D5L,
X/*45*/	0x75751EB9L,0x3E7F8185L,0x521C2605L,0xE1AAAB6EL,0x38EBB80FL,
X/*50*/	0xBEE7E904L,0x61CB9647L,0xEA54904EL,0x05AE00E4L,0x2D7AC65FL,
X/*55*/	0x087751A1L,0xDCD82915L,0x0921EE16L,0xDD86D33BL,0xD6BD491AL,
X/*60*/	0x40FBADF0L,0x4232CBD2L,0x33808D10L,0x39098C42L,0x193F3199L,
X/*65*/	0x0BC1E47AL,0x4A82B149L,0x02B65A8AL,0x104CDC8EL,0x24A8F52CL,
X/*70*/	0x685C6077L,0xC79F95C9L,0x1D11FE50L,0xC08DAFCDL,0x7B1A9A03L,
X/*75*/	0x1C1F11D8L,0x84250E7FL,0x979DB248L,0xEBDC0501L,0xB9553395L,
X/*80*/	0xE3C05EA8L,0xB1E51C4CL,0x13B0E681L,0x3B407766L,0x36DB3087L,
X/*85*/	0xEE17C9FCL,0x6C53ECF2L,0xADCCC58FL,0xC427660BL,0xEFD5867DL,
X/*90*/	0x9B6D54A5L,0x6FF1AEFFL,0x8E787952L,0x9E2BFFE0L,0x8761D034L,
X/*95*/	0xE00BDBADL,0xAE99A8D3L,0xCC03F6E2L,0xFD0ED807L,0x0E508AE3L,
X/*100*/	0xB74182ABL,0x4349245DL,0xD120A465L,0xB246A641L,0xAF3B7AB0L,
X/*105*/	0x2A6488BBL,0x4B3A0D1FL,0xE7C7E58CL,0x3FAFF2EBL,0x90445FFDL,
X/*110*/	0xCF38C393L,0x995D07E7L,0xF24F1B36L,0x356F6891L,0x6D6EBCBEL,
X/*115*/	0x8DA9E262L,0x50FD520EL,0x5BCA9E1EL,0x37472CF3L,0x69075057L,
X/*120*/	0x7EC5FDEDL,0x0CAB892AL,0xFB2412BAL,0x1728DEBFL,0xA000A988L,
X/*125*/	0xD843CE79L,0x042E20DDL,0x4FE8F853L,0x56659C3CL,0x2739D119L,
X/*130*/	0xA78A6120L,0x80960375L,0x70420611L,0x85E09F78L,0xABD17E96L,
X/*135*/	0x1B513EAFL,0x1E01EB63L,0x26AD2133L,0xA890C094L,0x7613CF60L,
X/*140*/	0x817E781BL,0xA39113D7L,0xE957FA58L,0x4131B99EL,0x28B1EFDAL,
X/*145*/	0x66ACFBA7L,0xFF68944AL,0x77A44FD1L,0x7F331522L,0x59FFB3FAL,
X/*150*/	0xA6DF935BL,0xFA12D9DFL,0xC6BF6F3FL,0x89520CF6L,0x659EDD6AL,
X/*155*/	0x544DA739L,0x8B052538L,0x7C30EA21L,0xC2345525L,0x15927FB2L,
X/*160*/	0x144A436BL,0xBA107B8BL,0x1219AC97L,0x06730432L,0x31831AB3L,
X/*165*/	0xC55A5C24L,0xAA0FCD3EL,0xE5606BE8L,0x5C88F19BL,0x4C0841EEL,
X/*170*/	0x1FE37267L,0x11F9C4F4L,0x9F1B9DAEL,0x864E76D0L,0xE637C731L,
X/*175*/	0xD97D23A6L,0x32F53D5CL,0xB8161980L,0x93FA0F84L,0xCAEF0870L,
X/*180*/	0x8874487EL,0x98F2CC73L,0x645FB5C6L,0xCD853659L,0x2062470DL,
X/*185*/	0x16EDE8E9L,0x6B06DAB5L,0x78B43900L,0xFC95B786L,0x5D8E7DE1L,
X/*190*/	0x465B5954L,0xFE7BA014L,0xF7D23F7BL,0x92BC8B18L,0x03593592L,
X/*195*/	0x55CEF4F7L,0x74B27317L,0x79DE1FC2L,0xC8A0BFBDL,0x229398CCL,
X/*200*/	0x62A602CEL,0xBCB94661L,0x5336D206L,0xD2A375FEL,0x6A6AB483L,
X/*205*/	0x4702A5A4L,0xA2E9D73DL,0x23A2E0F1L,0x9189140AL,0x581D18DCL,
X/*210*/	0xB39A922BL,0x82356212L,0xD5F432A9L,0xD356C2A3L,0x5F765B4DL,
X/*215*/	0x450AFCC8L,0x4415E137L,0xE8ECDFBCL,0xED0DE3EAL,0x60D42B13L,
X/*220*/	0xF13DF971L,0x71FC5DA2L,0xC1455340L,0xF087742FL,0xF55E5751L,
X/*225*/	0x67B3C1F8L,0xAC6B8774L,0x7DCFAAACL,0x95983BC0L,0x489BB0B1L,
X/*230*/	0x2C184223L,0x964B6726L,0x2BD3271CL,0x72266472L,0xDED64530L,
X/*235*/	0x0A2AA343L,0xD4F716A0L,0xB4DAD6D9L,0x2184345EL,0x512C990CL,
X/*240*/	0x29D92D08L,0x2EBE709AL,0x01144C69L,0x34584B9DL,0xE4634ED6L,
X/*245*/	0xECC963CFL,0x3C6984AAL,0x4ED056EFL,0x9CA56976L,0x8F3E80D4L,
X/*250*/	0xB5BAE7C5L,0x30B5CAF5L,0x63F33A64L,0xA9E4BBDEL,0xF6B82298L,
X/*255*/	0x4D673C1DL},
X	{
X		/* Start of S Box 5 */
X/*0*/	0x4B4F1121L,0xBA183081L,0xC784F41FL,0xD17D0BACL,0x083D2267L,
X/*5*/	0x37B1361EL,0x3581AD05L,0xFDA2F6BCL,0x1E892CDDL,0xB56D3C3AL,
X/*10*/	0x32140E46L,0x138D8AABL,0xE14773D4L,0x5B0E71DFL,0x5D1FE055L,
X/*15*/	0x3FB991D3L,0xF1F46C71L,0xA325988CL,0x10F66E80L,0xB1006348L,
X/*20*/	0x726A9F60L,0x3B67F8BAL,0x4E114EF4L,0x05C52115L,0x4C5CA11CL,
X/*25*/	0x99E1EFD8L,0x471B83B3L,0xCBF7E524L,0x43AD82F5L,0x690CA93BL,
X/*30*/	0xFAA61BB2L,0x12A832B5L,0xB734F943L,0xBD22AEA7L,0x88FEC626L,
X/*35*/	0x5E80C3E7L,0xBE3EAF5EL,0x44617652L,0xA5724475L,0xBB3B9695L,
X/*40*/	0x7F3FEE8FL,0x964E7DEBL,0x518C052DL,0x2A0BBC2BL,0xC2175F5CL,
X/*45*/	0x9A7B3889L,0xA70D8D0CL,0xEACCDD29L,0xCCCD6658L,0x34BB25E6L,
X/*50*/	0xB8391090L,0xF651356FL,0x52987C9EL,0x0C16C1CDL,0x8E372D3CL,
X/*55*/	0x2FC6EBBDL,0x6E5DA3E3L,0xB0E27239L,0x5F685738L,0x45411786L,
X/*60*/	0x067F65F8L,0x61778B40L,0x81AB2E65L,0x14C8F0F9L,0xA6B7B4CEL,
X/*65*/	0x4036EAECL,0xBF62B00AL,0xECFD5E02L,0x045449A6L,0xB20AFD28L,
X/*70*/	0x2166D273L,0x0D13A863L,0x89508756L,0xD51A7530L,0x2D653F7AL,
X/*75*/	0x3CDBDBC3L,0x80C9DF4FL,0x3D5812D9L,0x53FBB1F3L,0xC0F185C0L,
X/*80*/	0x7A3C3D7EL,0x68646410L,0x857607A0L,0x1D12622EL,0x97F33466L,
X/*85*/	0xDB4C9917L,0x6469607CL,0x566E043DL,0x79EF1EDBL,0x2C05898DL,
X/*90*/	0xC9578E25L,0xCD380101L,0x46E04377L,0x7D1CC7A9L,0x6552B837L,
X/*95*/	0x20192608L,0xB97500C5L,0xED296B44L,0x368648B4L,0x62995CD5L,
X/*100*/	0x82731400L,0xF9AEBD8BL,0x3844C0C7L,0x7C2DE794L,0x33A1A770L,
X/*105*/	0x8AE528C2L,0x5A2BE812L,0x1F8F4A07L,0x2B5ED7CAL,0x937EB564L,
X/*110*/	0x6FDA7E11L,0xE49B5D6CL,0xB4B3244EL,0x18AA53A4L,0x3A061334L,
X/*115*/	0x4D6067A3L,0x83BA5868L,0x9BDF4DFEL,0x7449F261L,0x709F8450L,
X/*120*/	0xCAD133CBL,0xDE941C3FL,0xF52AE484L,0x781D77EDL,0x7E4395F0L,
X/*125*/	0xAE103B59L,0x922331BBL,0x42CE50C8L,0xE6F08153L,0xE7D941D0L,
X/*130*/	0x5028ED6BL,0xB3D2C49BL,0xAD4D9C3EL,0xD201FB6EL,0xA45BD5BEL,
X/*135*/	0xFFCB7F4BL,0x579D7806L,0xF821BB5BL,0x59D592ADL,0xD0BE0C31L,
X/*140*/	0xD4E3B676L,0x0107165AL,0x0FE939D2L,0x49BCAAFDL,0x55FFCFE5L,
X/*145*/	0x2EC1F783L,0xF39A09A5L,0x3EB42772L,0x19B55A5DL,0x024A0679L,
X/*150*/	0x8C83B3F7L,0x8642BA1DL,0xACACD9EAL,0x87D352C4L,0x60931F45L,
X/*155*/	0xA05F97D7L,0x1CECD42CL,0xE2FCC87BL,0xB60F94E2L,0x67A34B0BL,
X/*160*/	0xFCDD40C9L,0x0B150A27L,0xD3EE9E04L,0x582E29E9L,0x4AC22B41L,
X/*165*/	0x6AC4E1B8L,0xBCCAA51AL,0x237AF30EL,0xEBC3B709L,0xC4A59D19L,
X/*170*/	0x284BC98AL,0xE9D41A93L,0x6BFA2018L,0x73B2D651L,0x11F9A2FAL,
X/*175*/	0xCE09BFF1L,0x41A470AAL,0x25888F22L,0x77E754E8L,0xF7330D8EL,
X/*180*/	0x158EAB16L,0xC5D68842L,0xC685A6F6L,0xE5B82FDEL,0x09EA3A96L,
X/*185*/	0x6DDE1536L,0x4FA919DAL,0x26C0BE9FL,0x9EED6F69L,0xF05555F2L,
X/*190*/	0xE06FC285L,0x9CD76D23L,0xAF452A92L,0xEFC74CB7L,0x9D6B4732L,
X/*195*/	0x8BE408EEL,0x22401D0DL,0xEE6C459DL,0x7587CB82L,0xE8746862L,
X/*200*/	0x5CBDDE87L,0x98794278L,0x31AFB94DL,0xC11E0F2FL,0x30E8FC2AL,
X/*205*/	0xCF3261EFL,0x1A3023E1L,0xAA2F86CFL,0xF202E24AL,0x8D08DCFFL,
X/*210*/	0x764837C6L,0xA26374CCL,0x9F7C3E88L,0x949CC57DL,0xDD26A07FL,
X/*215*/	0xC39EFAB0L,0xC8F879A1L,0xDCE67BB9L,0xF4B0A435L,0x912C9AE0L,
X/*220*/	0xD85603E4L,0x953A9BBFL,0xFB8290D6L,0x0AEBCD5FL,0x16206A9AL,
X/*225*/	0x6C787A14L,0xD9A0F16AL,0x29BF4F74L,0x8F8BCE91L,0x0E5A9354L,
X/*230*/	0xAB038CB1L,0x1B8AD11BL,0xE327FF49L,0x0053DA20L,0x90CF51DCL,
X/*235*/	0xDA92FE6DL,0x0390CA47L,0xA8958097L,0xA9DC5BAFL,0x3931E3C1L,
X/*240*/	0x840446B6L,0x63D069FBL,0xD7460299L,0x7124ECD1L,0x0791E613L,
X/*245*/	0x485918FCL,0xD635D04CL,0xDF96AC33L,0x66F2D303L,0x247056AEL,
X/*250*/	0xA1A7B2A8L,0x27D8CC9CL,0x17B6E998L,0x7BF5590FL,0xFE97F557L,
X/*255*/	0x5471D8A2},
X	{
X		/* Start of S Box 6 */
X/*0*/	0x83A327A1L,0x9F379F51L,0x40A7D007L,0x11307423L,0x224587C1L,
X/*5*/	0xAC27D63BL,0x3B7E64EAL,0x2E1CBFA6L,0x09996000L,0x03BC0E2CL,
X/*10*/	0xD4C4478AL,0x4542E0ABL,0xFEDA26D4L,0xC1D10FCBL,0x8252F596L,
X/*15*/	0x4494EB5CL,0xA362F314L,0xF5BA81FDL,0x75C3A376L,0x4CA214CAL,
X/*20*/	0xE164DEDDL,0x5088FA97L,0x4B0930E0L,0x2FCFB7E8L,0x33A6F4B2L,
X/*25*/	0xC7E94211L,0x2D66C774L,0x43BE8BAEL,0xC663D445L,0x908EB130L,
X/*30*/	0xF4E3BE15L,0x63B9D566L,0x529396B5L,0x1E1BE743L,0x4D5FF63FL,
X/*35*/	0x985E4A83L,0x71AB9DF7L,0xC516C6F5L,0x85C19AB4L,0x1F4DAEE4L,
X/*40*/	0xF2973431L,0xB713DC5EL,0x3F2E159AL,0xC824DA16L,0x06BF376AL,
X/*45*/	0xB2FE23ECL,0xE39B1C22L,0xF1EECB5FL,0x08E82D52L,0x565686C2L,
X/*50*/	0xAB0AEA93L,0xFD47219FL,0xEBDBABD7L,0x2404A185L,0x8C7312B9L,
X/*55*/	0xA8F2D828L,0x0C8902DAL,0x65B42B63L,0xC0BBEF62L,0x4E3E4CEFL,
X/*60*/	0x788F8018L,0xEE1EBAB7L,0x93928F9DL,0x683D2903L,0xD3B60689L,
X/*65*/	0xAFCB0DDCL,0x88A4C47AL,0xF6DD9C3DL,0x7EA5FCA0L,0x8A6D7244L,
X/*70*/	0xBE11F120L,0x04FF91B8L,0x8D2DC8C0L,0x27F97FDBL,0x7F9E1F47L,
X/*75*/	0x1734F0C7L,0x26F3ED8EL,0x0DF8F2BFL,0xB0833D9EL,0xE420A4E5L,
X/*80*/	0xA423CAE6L,0x95616772L,0x9AE6C049L,0x075941F2L,0xD8E12812L,
X/*85*/	0x000F6F4FL,0x3C0D6B05L,0x6CEF921CL,0xB82BC264L,0x396CB008L,
X/*90*/	0x5D608A6FL,0x6D7782C8L,0x186550AAL,0x6B6FEC09L,0x28E70B13L,
X/*95*/	0x57CE5688L,0xECD3AF84L,0x23335A95L,0x91F40CD2L,0x7B6A3B26L,
X/*100*/	0xBD32B3B6L,0x3754A6FBL,0x8ED088F0L,0xF867E87CL,0x20851746L,
X/*105*/	0x6410F9C6L,0x35380442L,0xC2CA10A7L,0x1ADEA27FL,0x76BDDD79L,
X/*110*/	0x92742CF4L,0x0E98F7EEL,0x164E931DL,0xB9C835B3L,0x69060A99L,
X/*115*/	0xB44C531EL,0xFA7B66FEL,0xC98A5B53L,0x7D95AAE9L,0x302F467BL,
X/*120*/	0x74B811DEL,0xF3866ABDL,0xB5B3D32DL,0xFC3157A4L,0xD251FE19L,
X/*125*/	0x0B5D8EACL,0xDA71FFD5L,0x47EA05A3L,0x05C6A9E1L,0xCA0EE958L,
X/*130*/	0x9939034DL,0x25DC5EDFL,0x79083CB1L,0x86768450L,0xCF757D6DL,
X/*135*/	0x5972B6BCL,0xA78D59C9L,0xC4AD8D41L,0x2A362AD3L,0xD1179991L,
X/*140*/	0x601407FFL,0xDCF50917L,0x587069D0L,0xE0821ED6L,0xDBB59427L,
X/*145*/	0x73911A4BL,0x7C904FC3L,0x844AFB92L,0x6F8C955DL,0xE8C0C5BBL,
X/*150*/	0xB67AB987L,0xA529D96CL,0xF91F7181L,0x618B1B06L,0xE718BB0CL,
X/*155*/	0x8BD7615BL,0xD5A93A59L,0x54AEF81BL,0x772136E3L,0xCE44FD9CL,
X/*160*/	0x10CDA57EL,0x87D66E0BL,0x3D798967L,0x1B2C1804L,0x3EDFBD68L,
X/*165*/	0x15F6E62BL,0xEF68B854L,0x3896DB35L,0x12B7B5E2L,0xCB489029L,
X/*170*/	0x9E4F98A5L,0x62EB77A8L,0x217C24A2L,0x964152F6L,0x49B2080AL,
X/*175*/	0x53D23EE7L,0x48FB6D69L,0x1903D190L,0x9449E494L,0xBF6E7886L,
X/*180*/	0xFB356CFAL,0x3A261365L,0x424BC1EBL,0xA1192570L,0x019CA782L,
X/*185*/	0x9D3F7E0EL,0x9C127575L,0xEDF02039L,0xAD57BCCEL,0x5C153277L,
X/*190*/	0x81A84540L,0xBCAA7356L,0xCCD59B60L,0xA62A629BL,0xA25CCD10L,
X/*195*/	0x2B5B65CFL,0x1C535832L,0x55FD4E3AL,0x31D9790DL,0xF06BC37DL,
X/*200*/	0x4AFC1D71L,0xAEED5533L,0xBA461634L,0xBB694B78L,0x5F3A5C73L,
X/*205*/	0x6A3C764AL,0x8FB0CCA9L,0xF725684CL,0x4FE5382FL,0x1D0163AFL,
X/*210*/	0x5AA07A8FL,0xE205A8EDL,0xC30BAD38L,0xFF22CF1FL,0x72432E2EL,
X/*215*/	0x32C2518BL,0x3487CE4EL,0x7AE0AC02L,0x709FA098L,0x0A3B395AL,
X/*220*/	0x5B4043F8L,0xA9E48C36L,0x149A8521L,0xD07DEE6BL,0x46ACD2F3L,
X/*225*/	0x8958DFFCL,0xB3A1223CL,0xB11D31C4L,0xCD7F4D3EL,0x0F28E3ADL,
X/*230*/	0xE5B100BEL,0xAAC54824L,0xE9C9D7BAL,0x9BD47001L,0x80F149B0L,
X/*235*/	0x66022F0FL,0x020C4048L,0x6EFA192AL,0x67073F8DL,0x13EC7BF9L,
X/*240*/	0x3655011AL,0xE6AFE157L,0xD9845F6EL,0xDECC4425L,0x511AE2CCL,
X/*245*/	0xDF81B4D8L,0xD7809E55L,0xD6D883D9L,0x2CC7978CL,0x5E787CC5L,
X/*250*/	0xDD0033D1L,0xA050C937L,0x97F75DCDL,0x299DE580L,0x41E2B261L,
X/*255*/	0xEA5A54F1L},
X	{
X		/* Start of S Box 7 */
X/*0*/	0x7E672590L,0xBEA513BBL,0x2C906FE6L,0x86029C2BL,0x55DC4F74L,
X/*5*/	0x0553398EL,0x63E09647L,0xCAFD0BABL,0x264C37DFL,0x8272210FL,
X/*10*/	0x67AFA669L,0x12D98A5FL,0x8CAB23C4L,0x75C68BD1L,0xC3370470L,
X/*15*/	0x33F37F4EL,0x283992FFL,0xE73A3A67L,0x1032F283L,0xF5AD9FC2L,
X/*20*/	0x963F0C5DL,0x664FBC45L,0x202BA41CL,0xC7C02D80L,0x54731E84L,
X/*25*/	0x8A1085F5L,0x601D80FBL,0x2F968E55L,0x35E96812L,0xE45A8F78L,
X/*30*/	0xBD7DE662L,0x3B6E6EADL,0x8097C5EFL,0x070B6781L,0xB1E508F3L,
X/*35*/	0x24E4FAE3L,0xB81A7805L,0xEC0FC918L,0x43C8774BL,0x9B2512A9L,
X/*40*/	0x2B05AD04L,0x32C2536FL,0xEDF236E0L,0x8BC4B0CFL,0xBACEB837L,
X/*45*/	0x4535B289L,0x0D0E94C3L,0xA5A371D0L,0xAD695A58L,0x39E3437DL,
X/*50*/	0x9186BFFCL,0x21038C3BL,0x0AA9DFF9L,0x5D1F06CEL,0x62DEF8A4L,
X/*55*/	0xF740A2B4L,0xA2575868L,0x682683C1L,0xDBB30FACL,0x61FE1928L,
X/*60*/	0x468A6511L,0xC61CD5F4L,0xE54D9800L,0x6B98D7F7L,0x8418B6A5L,
X/*65*/	0x5F09A5D2L,0x90B4E80BL,0x49B2C852L,0x69F11C77L,0x17412B7EL,
X/*70*/	0x7F6FC0EDL,0x56838DCCL,0x6E9546A2L,0xD0758619L,0x087B9B9AL,
X/*75*/	0xD231A01DL,0xAF46D415L,0x097060FDL,0xD920F657L,0x882D3F9FL,
X/*80*/	0x3AE7C3C9L,0xE8A00D9BL,0x4FE67EBEL,0x2EF80EB2L,0xC1916B0CL,
X/*85*/	0xF4DFFEA0L,0xB97EB3EBL,0xFDFF84DDL,0xFF8B14F1L,0xE96B0572L,
X/*90*/	0xF64B508CL,0xAE220A6EL,0x4423AE5AL,0xC2BECE5EL,0xDE27567CL,
X/*95*/	0xFC935C63L,0x47075573L,0xE65B27F0L,0xE121FD22L,0xF2668753L,
X/*100*/	0x2DEBF5D7L,0x8347E08DL,0xAC5EDA03L,0x2A7CEBE9L,0x3FE8D92EL,
X/*105*/	0x23542FE4L,0x1FA7BD50L,0xCF9B4102L,0x9D0DBA39L,0x9CB8902AL,
X/*110*/	0xA7249D8BL,0x0F6D667AL,0x5EBFA9ECL,0x6A594DF2L,0x79600938L,
X/*115*/	0x023B7591L,0xEA2C79C8L,0xC99D07EAL,0x64CB5EE1L,0x1A9CAB3DL,
X/*120*/	0x76DB9527L,0xC08E012FL,0x3DFB481AL,0x872F22E7L,0x2948D15CL,
X/*125*/	0xA4782C79L,0x6F50D232L,0x78F0728AL,0x5A87AAB1L,0xC4E2C19CL,
X/*130*/	0xEE767387L,0x1B2A1864L,0x7B8D10D3L,0xD1713161L,0x0EEAC456L,
X/*135*/	0xD8799E06L,0xB645B548L,0x4043CB65L,0xA874FB29L,0x4B12D030L,
X/*140*/	0x7D687413L,0x18EF9A1FL,0xD7631D4CL,0x5829C7DAL,0xCDFA30FAL,
X/*145*/	0xC5084BB0L,0x92CD20E2L,0xD4C16940L,0x03283EC0L,0xA917813FL,
X/*150*/	0x9A587D01L,0x70041F8FL,0xDC6AB1DCL,0xDDAEE3D5L,0x31829742L,
X/*155*/	0x198C022DL,0x1C9EAFCBL,0x5BBC6C49L,0xD3D3293AL,0x16D50007L,
X/*160*/	0x04BB8820L,0x3C5C2A41L,0x37EE7AF8L,0x8EB04025L,0x9313ECBAL,
X/*165*/	0xBFFC4799L,0x8955A744L,0xEF85D633L,0x504499A7L,0xA6CA6A86L,
X/*170*/	0xBB3D3297L,0xB34A8236L,0x6DCCBE4FL,0x06143394L,0xCE19FC7BL,
X/*175*/	0xCCC3C6C6L,0xE36254AEL,0x77B7EDA1L,0xA133DD9EL,0xEBF9356AL,
X/*180*/	0x513CCF88L,0xE2A1B417L,0x972EE5BDL,0x853824CDL,0x5752F4EEL,
X/*185*/	0x6C1142E8L,0x3EA4F309L,0xB2B5934AL,0xDFD628AAL,0x59ACEA3EL,
X/*190*/	0xA01EB92CL,0x389964BCL,0xDA305DD4L,0x019A59B7L,0x11D2CA93L,
X/*195*/	0xFAA6D3B9L,0x4E772ECAL,0x72651776L,0xFB4E5B0EL,0xA38F91A8L,
X/*200*/	0x1D0663B5L,0x30F4F192L,0xB50051B6L,0xB716CCB3L,0x4ABD1B59L,
X/*205*/	0x146C5F26L,0xF134E2DEL,0x00F67C6CL,0xB0E1B795L,0x98AA4EC7L,
X/*210*/	0x0CC73B34L,0x654276A3L,0x8D1BA871L,0x740A5216L,0xE0D01A23L,
X/*215*/	0x9ED161D6L,0x9F36A324L,0x993EBB7FL,0xFEB9491BL,0x365DDCDBL,
X/*220*/	0x810CFFC5L,0x71EC0382L,0x2249E7BFL,0x48817046L,0xF3A24A5BL,
X/*225*/	0x4288E4D9L,0x0BF5C243L,0x257FE151L,0x95B64C0DL,0x4164F066L,
X/*230*/	0xAAF7DB08L,0x73B1119DL,0x8F9F7BB8L,0xD6844596L,0xF07A34A6L,
X/*235*/	0x53943D0AL,0xF9DD166DL,0x7A8957AFL,0xF8BA3CE5L,0x27C9621EL,
X/*240*/	0x5CDAE910L,0xC8518998L,0x941538FEL,0x136115D8L,0xABA8443CL,
X/*245*/	0x4D01F931L,0x34EDF760L,0xB45F266BL,0xD5D4DE14L,0x52D8AC35L,
X/*250*/	0x15CFD885L,0xCBC5CD21L,0x4CD76D4DL,0x7C80EF54L,0xBC92EE75L,
X/*255*/	0x1E56A1F6L}
X};
END_OF_FILE
if test 30068 -ne `wc -c <'sb.c'`; then
    echo shar: \"'sb.c'\" unpacked with wrong size!
fi
# end of 'sb.c'
fi
if test -f 'sign.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sign.1'\"
else
echo shar: Extracting \"'sign.1'\" \(2239 characters\)
sed "s/^X//" >'sign.1' <<'END_OF_FILE'
X.TH "SIGN" 1 "May 8, 1990" "Hash Signatures"
X.SH NAME
Xsign - digitally sign a file
X.SH SYNOPSIS
Xsign  [ - | -m message ] userKey file(s)
X.SH FOR EXPERIMENTAL USE ONLY
X
X.SH DESCRIPTION
X.B Sign
Xdigitally signs the given files in the name of the logged-in
Xuser using the specified user key.  The secret key is regenerated by
Xcombining the user key and the machine key (which is read from the private directory).
XThe signature is put into the signature file, currently created by
Xprefixing the string ".JZ" to the file name.
XThe original signed file is not altered.
X.PP
XIf the optional -m message is given, the given message is
Xincluded in the signature and authenticated along with the
Xinput file.  If only "-" is specified, characters are read
Xfrom standard input until EOF, included in the signature, and
Xauthenticated along with the file.
X.SH EXAMPLES
Xsign "My secret key" /bin/*
X.PP
XSigns all the files in /bin.  Modification of any of the
Xfiles (by, for example, a virus) can later be
Xdetected by checking the signature.
X
Xsign -m "Flakey, but no viruses" Adf4vioqe3 newVersion
X.PP
XSigns the file newVersion, and includes the (authenticated)
Xmessage "Flakey, but no viruses" in the signature file.
X
Xsign - d3nfka90cf niftyNewHack
X.br
XI received this code on March 3, 1990, from M. Mouse.
XHe says the code is reliable, virus free, and trustworthy.
X.br
X^d
X.PP
XSigns the file "niftyNewHack" and includes the message
Xtyped in on standard input up to the ^d (end-of-file).
XThe typed in message will be verified and then displayed
Xwhen the signature is checked.
X.SH FILES
X"sign" expects to find public checking keys in the public directory:
X/net/palain/rouge/pubdir.  It expects to find two copies of the
Xmachine key in the two directories (on two distinct disk drives):
X/net/palain/rouge/privdir and
X/net/palain/jaune/privdir.  An auxilliary directory that contains
Xauxilliary information which is not security critical is:
X/net/palain/rouge/auxdir.
X.SH BUGS
XThe user key is echoed on the command line, rather than being entered
Xfrom the terminal with echoing turned off.
X.SH "SEE ALSO"
Xcheck(1) makepublickey(1) destroyoldkey(1) dumpsig(1) recoverauxinfo(1)
X.SH AUTHOR
XRalph C. Merkle
XCopyright (C) 1990 Xerox Corporation
XAll Rights Reserved
END_OF_FILE
if test 2239 -ne `wc -c <'sign.1'`; then
    echo shar: \"'sign.1'\" unpacked with wrong size!
fi
# end of 'sign.1'
fi
if test -f 'signCheck1.0.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'signCheck1.0.c'\"
else
echo shar: Extracting \"'signCheck1.0.c'\" \(130003 characters\)
sed "s/^X//" >'signCheck1.0.c' <<'END_OF_FILE'
X/*
X   This is an experimental implementation of the signing and checking
X   algorithms for a digital signature based on one-way hash functions. The
X   new signature method is, for this reason, called a "hash signature." Many
X   methods of generating a digital signature from a one-way hash function are
X   feasible, so to distinguish this particular method it is called the
X   "Xerox Hash Signature."  The Xerox Hash Signature presently includes
X   three separate components:
X
X     1.)  The Abstract Xerox Hash Signature.  This includes the software
X          which defines how to use a one-way hash function to generate
X          a digital signature, but excludes the software of any particular
X          one way hash function.  In this implementation, the Abstract
X          Xerox Hash Signature specifically excludes both MD4 and Snefru.
X          The Abstract Xerox Hash Signature specifies how to generate
X          a digital signature given a one-way hash function, but does
X          NOT specify any particular signature system, nor any particular
X          one-way hash function.
X
X     2.)  The one-way hash function Snefru (4 passes).
X
X     3.)  The one-way hash function MD4.
X
X*    Addendum dated 91.11.13:  since the original implementation of this
X*    system, MD5 has been made available and MD4 is no longer recommended.
X*    Further, Snefru with 8 passes has been made available, and Snefru
X*    with 4 passes is no longer recommended.  For these and various other
X*    reasons, the present system should be viewed as a experimental, and
X*    is not intended for production use.
X
X   It is convenient to have a name for the combination of these components.
X   In general, the term "Xerox Hash Signature" refers to one or more specific
X   digital signatures generated by combining the Abstract Xerox Hash Signature
X   with one or more specific one-way hash functions. In this particular case,
X   the Xerox Hash Signature refers to the coupling of the Abstract Xerox Hash
X   Signature with the particular one-way hash functions Snefru or MD4.
X
X   In other contexts, the term "Xerox Hash Signature" could be used to
X   describe the coupling of the Abstract Xerox Hash Signature with other
X   specific one-way hash functions. When it is necessary to discuss a
X   specific digital signature method created by coupling the Abstract Xerox
X   Hash Signature with some specific one-way hash function, the combination
X   can use the name "The Xerox Hash Signature based on <name of one-way hash 
X   function>."  For example, the present software can be specifically described
X   as the Xerox Hash Signature based on Snefru or MD4.
X
X   In general, the signature system described by the term "The Xerox Hash
X   Signature" will be determined by context.  The term "The Abstract Xerox
X   Hash Signature" refers specifically to the general method of combining
X   an arbitrary one-way hash function into a digital signature system, but
X   does not include any particular one-way hash function nor does it define
X   or specify any particular implementation of a digital signature.  Only
X   when the Abstract Xerox Hash Signature is combined with some specific one
X   way hash function have we defined a particular digital signature.
X
X   Both Snefru and MD4 are available separately.  Both Snefru and MD4 are
X   accompanied by separate notices.  The implementations of Snefru and MD4
X   included here have been modified for convenient use with the present
X   software, but they are distinct entities.  The notices which accompany
X   Snefru and MD4 have been reproduced in the appropriate files.  Those
X   notices do not pertain to the Abstract Xerox Hash Signature, which
X   is a separate and distinct software entity and which is covered by
X   separate and distinct notices, which follow:
X
X**************************************************************************
X   COPYRIGHT (C) 1990 Xerox corporation.  All rights reserved.
X
X   XEROX CORPORATION MAKES NO REPRESENTATIONS CONCERNING EITHER THE
X   MERCHANTABILITY OF THIS SOFTWARE OR THE SUITABILITY OF THIS SOFTWARE FOR
X   ANY PARTICULAR PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED
X   WARRANTY OF ANY KIND.
X
X   This software is being made available for experimental use only.  No
X   right is granted to use this software for any other purpose.  The rights
X   (if any) granted for using the individual modules of this software are
X   specified by notices appearing in those modules.
X
X   Further, in the author's opinion, it is very possible that one or more
X   security related bugs exist in this experimental implementation.
X   Also note that the routine OpenAndLockTwoFiles has been modified
X   to improve portability, but this has created a timing window.
X   This should not significantly affect experimental use.
X
X   This software may be covered by one or more claims of either or
X   both of the following patents:
X
X   #4,881,264:
X   Digital Signature System and Method
X  	 Based on a Conventional Encryption Function
X   Issued:		November 14, 1989.
X   Inventor:		Ralph C. Merkle.
X   Patent owned by:	Ralph C. Merkle.
X   Contact:		Ralph C. Merkle
X			Xerox PARC
X			3333 Coyote Hill Road
X			Palo Alto, CA 94304
X			merkle@xerox.com
X
X   #4,309,569:
X   Method of Providing Digital Signatures
X   Issued:		January 5, 1982.
X   Inventor:		Ralph C. Merkle.
X   Patent owned by:	Stanford University.
X   Contact:		Joe Koepnick
X			Stanford University
X			Office of Technology Licensing
X			857 Serra Street, Second Floor
X			Stanford, CA 94305-6225.
X			koepnick@angelo.Stanford.EDU
X
X   XEROX MAKES NO REPRESENTATION WHATSOEVER WITH RESPECT TO THE RELEVANCE
X   OF SUCH PATENTS TO THIS SOFTWARE OR WITH RESPECT TO THE VALIDITY OF
X   THESE PATENTS.  XEROX AUTHORIZES NO USES OF THE ABSTRACT XEROX HASH
X   SIGNATURE EXCEPT FOR THOSE THAT ARE STRICTLY LIMITED TO EXPERIMENTAL
X   PURPOSES.
X
X   These notices must be retained in any copies of any part of this software.
X**************************************************************************
X
X   The following papers describe some of the concepts and ideas used in
X   this program:
X
X   "A Certified Digital Signature" by Ralph C. Merkle, Crypto '89.
X   "One Way Hash Functions and DES" by Ralph C. Merkle, Crypto '89.
X   "A Fast Software One Way Hash Function" by Ralph C. Merkle, accepted by
X        The Journal of Cryptology.
X   "A Digital Signature Based On A Conventional Encryption Function" by
X        Ralph C. Merkle, Crypto '87.
X   "Secrecy, Authentication, and Public Key Systems" by Ralph C. Merkle,
X        Ph.D. Thesis, Stanford University Electrical Engineering Dept. 1979.
X   "Design Principles for Hash Functions" by Ivan Bjerre Damgard, Crypto '89.
X   "Constructing Digital Signatures from a One Way Function" by
X        Leslie Lamport, Computer Science Laboratory Technical Report
X        October 18, 1979, CSL-98
X
X   This is version 1.0d, June 19, 1990.
X
X   THE SIGNING ALGORITHM
X
X   The signing algorithm accepts, as input,
X   
X   1.)  An input file <input> to be signed, and an optional short
X   ascii "message" that accompanies the signed file.
X
X   2.)  The "current auxilliary information" (a file) which keeps track
X   of various bookkeeping information.  The file is not secret, and
X   the information in it can be divulged without compromising the
X   security of the signature. Loss or destruction of the aux info file
X   is not a catastrophe -- the information in it can be re-computed from
X   the machine key file and the secret user key using the "recoverauxinfo"
X   command.
X   
X   3.)  A "user key" entered by the user.  The user
X   key is not retained by the program after the message has been signed.
X
X   4.)  A "machine key" file that holds a "machine key" and the
X   authentication path.  If the "machine key" is compromised, then
X   the security of the system rests solely on the user key.  If the
X   user key is compromised, then the security of the system rests
X   solely on the machine key.  Both keys together are required to
X   generate the "secret key" that is actually used to sign messages.
X
X   The use of two separate keys has two distinct purposes:
X     (a) It means that guessing the user key (which is often ill-chosen
X         by an unsophisticated or disinterested user) will not compromise
X         the machine key or the secret key, thus improving security, and
X     (b) It insures that the user will not use the same secret key
X         to generate a new secret-key/public-key pair.  Generating the
X         same secret-key/public-key pair and signing two sets of
X         messages with it will seriously compromise security.
X
X   The "machine key" file must also be resistant to unauthorized
X   modification -- unauthorized changes to the "authentication path"
X   specified in this file can compromise security.  In most applications,
X   it would also be advisable to make the "machine key" unreadable
X   by anyone other than those properly authorized.
X   
X   The signing algorithm produces as output:
X   
X   1.)  A "signature file."  This file is normally .JZ<input file>,
X   (e.g., the input file name prefixed with ".JZ").
X
X   THE CHECKING ALGORITHM
X
X   The checking algorithm re-computes the public key from the signature
X   and the signed file.  The signed file and message are first hashed
X   using a one-way hash function (Snefru 2.0 or MD4, other algorithms
X   can be added easily) to 128 bits.  This 128-bit hash value is
X   then further hashed to 64-bits using a parameterized one-way hash
X   function.  This 64-bit value is then hashed to compute the
X   public key.  The public key is then looked up in a public
X   directory to determine the signer.  If no matching public key
X   is found in the public directory, the signer is unknown.
X
X   Note that re-computing the public key is idiosyncratic to hash
X   signatures.  Other signature methods do not re-compute the
X   public key, but instead require that the public key be entered
X   as a parameter to the signature checking algorithm.  This
X   difference might be confusing for those familiar with the
X   normal methods of checking a signature.
X   
X   Input for the checking algorithm is:
X   
X   1.)  An input file <input> whose signature is to be checked.
X
X   2.)  The signature file, .JZ<input>.
X
X   Output from the checking algorithm is:
X
X   1.)  The re-computed public key.
X
X
X   The re-computed public key is used to find any matching
X   (previously authenticated) public keys present in the public directory.
X   If such a match is found, then the program prints out the name
X   of the signer and other information taken from the signed message
X   and the public entry.  If no known public key matches the
X   re-computed public key, then a diagnostic is issued.
X
X   Clearly, the correctness of the result depends on the validity of
X   the entries in the public directory.  Various methods of
X   safeguarding the public entries have been proposed in the
X   literature.  A consideration of these methods is beyond the scope
X   of these comments.
X
X   In general, the security of hash signatures is dependent on the security of
X   the underlieing one-way hash function. If that one-way hash function is
X   secure, then the signature method is secure.  Two one-way hash functions
X   suitable for use in this hash signature are:  Snefru 2.0 (with 4 passes)
X   and MD4.  Other one-way hash functions can be easily added to the code.
X   The selection of which one way-hash function to use can be based on any of
X   several criteria, including performance, perceived security, availability,
X   etc.
X   
X   Snefru 2.0 is available via anonymous FTP from arisia.xerox.com in directory
X   /pub/hash.   (MD4 is also available in the same directory as a courtesy).
X
X   MD4 has not yet received adequate review to establish its security.
X   Its security should therefore be viewed with caution at the
X   present time (90.04.25).
X
XFurther information about MD4 is available from:
X	RSA Data Security.
X	10 Twin Dolphin Drive
X	Redwood City, CA 94065
X	415-595-8782
X	rsa@well.uucp
X
XEither Snefru or MD4 can be
Xused in the current hash signature method by setting the "hashMethod"
Xvariable appropriately.  Snefru is set to 4 passes.  Setting Snefru
Xto 2 passes is known to be insecure (courtesy of the work of Eli Biham).
XThis is available by setting the "hashMethod" variable to SNEFRU4_METHOD.
XMD4 can be specified by setting "hashMethod" to MD4_METHOD.
X
XSnefru with 2 passes can be broken.  The security of Snefru with 4 passes
Xhas not yet received adequate analysis and its use must be viewed with
Xcaution at the present time (90.04.25).
X
X*  Addendum added 91.11.13:  Snefru with 8 passes and MD5 are both
X*  available.  For these and other reasons, the present software
X*  should be viewed as experimental.  Use of the present system
X*  for production use is not recommended.
X
XPlease note that the constant values that specify different hash
Xmethods must be unique.  For this reason, anyone who wishes to add
Xa new method should contact Ralph C. Merkle to insure that the
Xconstant value selected does not conflict with other values.  In
Xany event, constants below 100 (decimal) are reserved for use by
XXerox.
X
XOther one - way hash functions are known.  DES-based one-way
Xhash functions could be used, but the inclusion of DES source
Xcode here might create export issues.  DES-based one way hash
Xfunctions are significantly slower than the two functions
Xspecifically designed for software implementation, Snefru and MD4;
Xon the other hand it is reasonable to place greater confidence
Xin the security of the recent IBM proposal based on DES.
X(Note that the security of other DES-based one-way hash
Xfunctions should be viewed with great caution).  Other one-way hash
Xfunctions known to the author at this time are either significantly
Xless efficient or are still subject to serious reservations about
Xsecurity.
X
X*  Addendum added 91.11.13:  it is expected that NIST will soon
X*  adopt a one way hash function.  This hash function could be
X*  adopted as the basis for the hash signature, in which case the
X*  security of the system would depend on the security of the NIST
X*  provided one-way hash function (modulo the fact that it is likely
X*  that some security-related bugs exist in this implementation).
X
XThe two values "securitySize" and "parameterSize"
Xdirectly control the security that is provided by the hash
Xsignature.  "securitySize" is the number of 32 - bit words that
Xare used to hold security-critical values.  "parameterSize" is
Xthe number of 32-bit words used to hold the security-related
X"parameter" values.  It is expected that securitySize will
Xeither be  2 (providing 64 bits of effective security) or 3
X(providing 96 bits of effective security).  The value of
XparameterSize will usually be 2 (providing 2 ** 64 possible parameters).
XNote that "parameters" to the one-way hash function need not be
Xrandomly selected from a large space.  However, different applications
Xof the one-way hash function should normally use different values
Xfor the parameter.  Thus, parameter values might start at 1 and proceed
Xsystematically through 2, 3, 4, etc.  Accidental re-use of the same
Xparameter value has only a minor impact on security, but widespread
Xre-use of the same parameter value would substantially reduce security.
X
XSetting both securitySize and parameterSize to 2 (64 bits) should
Xprovide a level of security sufficient for most commercial
Xapplications.  For applications requiring a higher level of security,
XsecuritySize can be increased.  In most applications, even at
Xa very high security level, it will not be necessary to increase
XparameterSize.  The security of the one-way hash functions is also
Xextremely important.  At this point in time, both Snefru 2.0 and MD4
Xare receiving widespread scrutiny.  It is too early to make reliable
Xstatements about the level of security that they provide.
X
XNote:  Snefru 2.0 with 2 passes was broken by Eli Biham, a PhD student of
XAdi Shamir's.  As a consequence, the use of 2 passes is not recommended.
XIt would seem prudent to use 4 passes at the time of this writing
X(90.04.25).
X
XFurther note:  Although it is in general possible to prove that
Xhash signatures are secure if the underlieing one-way hash function
Xis secure, it should be remembered that the present program has
Xsome 6,000 lines of code in it.  The present code has not been reviewed
Xby anyone other than the author, nor does the author make any claims
Xof infallibility.  It is therefore probable that some security related
Xbugs exist in the present implementation.  This implementation should
Xbe verified or re-implemented independently prior to any non-experimental
Xuse.
X
XIf anyone using this program finds a bug or error, please contact
XRalph C.Merkle via E-mail (merkle@xerox.com) or
Xvia normal mail at:
X
X		Xerox PARC
X		3333 Coyote Hill Road
X		Palo Alto, CA 94304
X		(415) 494-4000
X
X
X
XA signature (the contents of the ".sig" file) has the following
Xdata structure:
X
Xbits	description
X	
X    word 0
X16	hashMethod.  Uniquely identifies the particular method used.
X4		Reserved for future use -- set to 0 for now
X4	securitySize (in 32-bit words)
X4	parameterSize (in 32-bit words)
X4	bitsPerVerifier
X
X    word 1
X16	total number of words (in the signature itself) to be hashed
X8	number of words of binary data (excluding the ascii message)
X8	number of OTTs (One Time Trees) in this signature
X
X    word 2
X32	The date and time the message was signed, in seconds since
X	00:00:00 GMT,  Jan.  1,  1970.  (Standard UNIX time format).
X
X    word 3
X128	hash value of file being signed.  Can occupy more than 4 words
X        depending on the value of "securitySize".
X
X    word 7
X64	initial parameter.  Can occupy more than 2 words depending on the
X        value of "parameterSize".
X
X    word 9
X0	Additional binary data.  Can occupy more than 0 words depending
X        on the value in the "number of words of binary data" field
X        (see above).
X
X    word 9
X0	An ascii text message to be associated with the signature.  Can
X        occupy more than 0 words depending on the "total number of words"
X        field (see above).
X
X    Further 32-bit words:
X  Repeat the following block according to the
X  8-bit "number of OTTs" (One Time Trees) parameter.
X
X64	count verifier   (size varies according to "securitySize")
X64	count verifier
X    .
X    . repeated 2**bitsPerVerifier times
X    .
X64	count verifier
X32	path description (Fixed at 32 bits for all time)
X64	branch verifier  (size varies according to "securitySize")
X64	branch verifier
X64	branch verifier
X   .
X   .  repeated according to "path description" (up to 31 times)
X   .
X64	branch verifier
X64	branch verifier
X
X   End of repeated block
X
X
X   Both the count verifiers and the branch verifiers given above can be
X   increased in size in increments of 32 bits.  When securitySize is
X   2 they will be 64 bits (as shown); when securitySize is 3 they
X   would be 96 bits, when securitySize is 4 they would be 128 bits,
X   etc.
X   
X   The 64-bit initial parameter can be increased in size in increments
X   of 32 bits by increasing the parameterSize from 2.  Thus, when
X   parameterSize is 2 the initial parameter will be 64 bits (as
X   shown).  When the parameterSize is 3, the initial parameter will
X   be 96 bits.  When the parameterSize is 4, the initial parameter
X   will be 128 bits.
X   
X   The path description will always be 32 bits.
X   
X   
X   Note that "word32" MUST be 32 bits
X   
X   Inventor, designer, and implementor:  Ralph C. Merkle
X   
X*/
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/time.h>
X#include <fcntl.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <pwd.h>
X#include "md4.h"
X#include "wellKnownDirectories"
X
X	/* security related parameters */
X#define MAX_PARAMETER_SIZE 4
X#define MAX_SECURITY_SIZE 4
X#define MAX_PUBLIC_KEY_SIZE (1+MAX_PARAMETER_SIZE+MAX_SECURITY_SIZE)
X#define MACHINE_KEY_SIZE 4
X#define USER_KEY_SIZE  8
X#define USER_KEY_SIZE_IN_BYTES (4*USER_KEY_SIZE)
X#define SECRET_KEY_SIZE 4
X#define HASHED_USER_KEY_SIZE 2
X#define WORD_SIZE_IN_BITS 32
X#define MAX_HASH_VALUE_SIZE (2*MAX_SECURITY_SIZE)
X
X/*
X * Hash method constants.
X * Note:  DO NOT add an additional hash method constant without
X * contacting Xerox.  These constants must be globally
X * unique.  Values less than 100 are reserved by Xerox and
X * should not be used by others.
X */
X#define MD4_METHOD 100
X#define SNEFRU4_METHOD 4
X
X	/*  other parameters and constants */
X#define MAX_OTT_SIZE 128 
X#define MAX_BITS_PER_VERIFIER 10
X#define TRUE 1
X#define FALSE 0
X#define SIGN 1
X#define CHECK 0
X#define COMPUTE_OTT_HASH 2
X#define PATHOVERFLOW 1
X#define NOPATHOVERFLOW 0
X#define DO_NOT_CREATE_FILE 1
X#define CREATE_FILE 0
X#define MAX_INPUT_BLOCK_SIZE 16
X#define SNEFRU_INPUT_BLOCK_SIZE 16
X#define INPUT_BLOCK_SIZE 16
X#define MAX_SIGNATURE_SIZE 4096
X#define MAX_FILE_NAME_SIZE_IN_BYTES 100
X/* warning!  If you change MAX_USER_NAME_SIZE_IN_BYTES,
X * scan through the source for all occurences --
X * some occurences are in quotes and so cannot
X * be expanded by the pre-processor (and
X * just have the integer value 300...)
X */
X#define MAX_USER_NAME_SIZE_IN_BYTES 300
X#define MAX_LINE_LENGTH 1000
X#define MAX_NO_OF_COUNTS 50
X#define MAX_STACK_DEPTH 10
X#define MAX_MESSAGE_SIZE 512
X#define MAX_MESSAGE_SIZE_IN_BYTES (MAX_MESSAGE_SIZE*4)
X#define DEBUG 0
X#define SELF_TEST 0
X#define SHOW_TIMES 0
X#define SHORT_UNUSUAL_STRING "JZ"
X#define MIN_DEPTH 1
X#define WIPE_IT 4096
X#define VERSION "@(#) Hash Signatures Version 1.0d June 19, 1990"
X
Xtypedef unsigned long int word32;
X
X	struct SIG_BUF {
X		word32 signature[MAX_SIGNATURE_SIZE];
X		int     locInSignature;
X	};
X
Xvoid HashExpand();
Xvoid HashAny();
Xvoid DoSelfTest();
Xvoid Snefru512();
Xlong clock();
Xlong time();
Xchar *sprintf();
Xvoid SnefruHashFile();
X
X#if DEBUG
Xvoid 
XPrintIt (string, val, length)
X	char   *string;
X	word32 val[];
X	int     length;
X{	int     di;
X	printf ("%s", string);
X	for (di = 0; di < length; di++)
X		printf (" %lx", val[di]);
X	printf ("\n");
X}
X#endif
X
X/*
X * Compute the number of bits required to represent the given value
X */
Xint 
XSizeInBits (value)
X	word32 value;
X{	int     i;
X
X	for (i = 0; i < WORD_SIZE_IN_BITS; i++)
X		if ((value >> i) == 0)
X			return (i);
X	return (WORD_SIZE_IN_BITS);
X}
X
X
X/*
X * Copy an input array to an output array of "size" words. The following
X * routine can be replaced with "memcpy" if this is defined in your
X * implementation.
X */
Xvoid 
XCopy (out, in, size)
X	word32 in[];
X	word32 out[];
X	int     size;
X{	int     i;
X	for (i = 0; i < size; i++)
X		out[i] = in[i];
X}
X
X/*
X * The following routine is a simple error exit routine  -- it prints a
X * message and aborts
X */
Xvoid 
XErrAbort (s)
X	char   *s;
X{	/*  Don't print empty strings */
X	if (s[0] != (char) 0)
X		fprintf (stderr, "%s\n", s);
X	exit (2);
X};
X
X/*
X * PORTABILITY WARNING:  The following routine should port
X * to most Unix systems.  It returns the GMT time in seconds since
X * January 1, 1970.
X */
Xlong
XGetTime32()
X{	time_t temp[1];
X
X	(void) time(temp);
X	return(temp[0]);
X}
X
X#if SHOW_TIMES
X/*
X * PORTABILITY WARNING:  The following routine should port to
X * most Unix systems. It returns the cpu time in microseconds.
X */
Xword32
XGetCpuTime()
X{
X	return(clock());
X}
X#endif
X
X
X/* PORTABILITY WARNING: The following routine should
X * be moderately portable among Unix systems.
X * It is intended to create a new
X * file and set the access modes for that file to
X * READ and WRITE by the creator of the file, but
X * to disallow any access (read, write, or anything else)
X * by others.  It returns a stream that will
X * be used to write information to the created file.
X *
X * If the file already exists, this routine will check
X * to see if it's "empty".  By definition, an "empty"
X * file has 4 bytes of "0" at its beginning (or a length
X * of less than 4 bytes).  If the file is empty, the stream
X * is returned.  If the file is not empty, a diagnostic
X * is issued.
X *
X */
XFILE *
XOpenIfEmpty(fileName)
Xchar *fileName;
X{	int	fd;
X	FILE	*stream;
X	char	temp[4];
X	int	length;
X	int	i;
X
X	fd = open(fileName, O_WRONLY | O_CREAT | O_EXCL, 0600);
X	stream = fdopen(fd, "w");
X	if (stream == NULL){
X		stream = fopen(fileName, "r+");
X		if (stream == NULL) {
X			fprintf(stderr, "Can't read from \"%s\"\n", fileName);
X			ErrAbort("");
X		};
X		length = fread(temp, 1, 4, stream);
X		if (ferror(stream) != 0) {
X			fprintf(stderr, "Can't access \"%s\"\n", fileName);
X			ErrAbort("");
X		};
X		for (i=0; i<length; i++)
X			if (temp[i] != 0) {
X				fprintf(stderr, "File \"%s\" is not empty\n",
X					fileName);
X				ErrAbort(
X				"To destroy old key, use \"destroyoldkey\"");
X			};
X		fseek(stream, 0L, 0);
X	};
X	return(stream);
X}
X
X/* PORTABILITY WARNING: THE FOLLOWING ROUTINE IS NOT VERY PORTABLE.
X * The following routine is intended to open and lock two files.
X * This will prevent two versions of the current program
X * from simultaneously attempting to update stable storage.
X *
X * For experimental purposes, the locking features of this routine
X * can simply be deleted (e.g., the calls to fcntl can be removed).
X * It should be remembered that THIS WILL PRODUCE A TIMING WINDOW
X * WHICH CAN RESULT IN LOSS OF SECURITY IF TWO PROGRAMS ATTEMPT
X * TO SIGN A MESSAGE WITH THE SAME SIGNING KEY AT THE SAME TIME.
X */
Xvoid
XOpenAndLockTwoFiles(s1Ptr, s1Name, s2Ptr, s2Name)
X	FILE	**s1Ptr;
X	char	*s1Name;
X	FILE	**s2Ptr;
X	char	*s2Name;
X{	int	fd1;
X	int	fd2;
X	struct flock localLock;
X
X	*s1Ptr = fopen(s1Name, "r+");
X	*s2Ptr = fopen(s2Name, "r+");
X	if (*s1Ptr == NULL) {
X		fprintf(stderr, "Can't open \"%s\"\n", s1Name);
X		ErrAbort("");
X	};
X	if (*s2Ptr == NULL) {
X		fprintf(stderr, "Can't open \"%s\"\n", s2Name);
X		ErrAbort("");
X	};
X	fd1 = fileno(*s1Ptr);
X	fd2 = fileno(*s2Ptr);
X	localLock.l_type = F_WRLCK;
X	localLock.l_whence = 0;
X	localLock.l_start = 0;
X	localLock.l_len = 0;
X/*  WARNING:  REMOVAL OF THE FOLLOWING TWO STATEMENTS CREATES
X *  A TIMEING WINDOW.  THIS SHOULD NOT MATTER FOR EXPERIMENTAL
X *  USAGE, BUT SHOULD NOT BE ALLOWED IN A PRODUCTION VERSION
X */
X/*
X	if (fcntl(fd1, F_SETLKW, (int) &localLock) == -1) {
X		fprintf(stderr, "Can't lock \"%s\"\n", s1Name);
X		ErrAbort("");
X	};
X	if (fcntl(fd2, F_SETLKW, (int) &localLock) == -1) {
X		fprintf(stderr, "Can't lock \"%s\"\n", s2Name);
X		ErrAbort("");
X	};
X */
X}
X
X
X/*
X * The following routine closes a file.  If there are problems
X * with the close, it prints an error message and calls ErrAbort.
X */
Xvoid
XFileClose(stream, streamName)
X	FILE	*stream;
X	char	*streamName;
X{
X	if (fclose(stream) != 0) {
X		fprintf(stderr, "Can't fclose \"%s\"\n", streamName);
X		ErrAbort("");
X	};
X}
X
X
X/* PORTABILITY WARNING.  THIS ROUTINE IS NOT VERY PORTABLE.
X * The following routine is intended to "sync" a file and then
X * close it, e.g., make sure the file is actually written to disk.
X * The routine fflush will do this on some systems (though
X * not all).  The routine fsync will do this, but is
X * not widely portable.  The exact method of implementing
X * FileSyncAndClose will vary from system to system.
X *
X * Note that FileSyncAndClose is presumed to "unlock" the file
X * as well as closing it.
X */
Xvoid
XFileSyncAndClose(stream, streamName)
X	FILE	*stream;
X	char	*streamName;
X{	int	fd;
X
X	if (fflush(stream) != 0) {
X		fprintf(stderr, "Can't fflush \"%s\"\n", streamName);
X		ErrAbort("");
X	};
X	fd = fileno(stream);
X	if (fsync(fd) != 0) {
X		fprintf(stderr, "Can't fsync \"%s\"\n", streamName);
X		ErrAbort("");
X	};
X	FileClose (stream, streamName);
X}
X
X/*
X * PORTABILITY WARNING:  The following routine is not very
X * portable, although it should work on most Unix systems.
X *
X * It returns 0 if the file exists, non-zero otherwise
X */
Xint
XFileExists(fileName)
X	char	*fileName;
X{	struct stat buf[1];
X
X	return(stat(fileName, buf));
X}
X
X/*
X * PORTABILITY WARNING:  The following routine is not very
X * portable, although it should work on most Unix systems.
X *
X * It returns 0 if the file exists and has a non-zero length
X */
Xint
XSignatureExists(fileName)
X	char	*fileName;
X{	struct stat buf[1];
X
X	if (stat(fileName, buf) != 0)
X		return(-1);
X	if (buf->st_size == 0)
X		return(-1);
X	return(0);
X}
X
X
X/*
X * PORTABILITY WARNING:  The following routine is not very
X * portable, although it should work on most Unix systems.
X *
X * Returns the name of the owner of the file
X */
Xchar *
XFileOwnersName(file)
X	FILE	*file;
X{	struct passwd	temp[1];
X	struct stat	buf[1];
X	static	char	ownersName[MAX_USER_NAME_SIZE_IN_BYTES];
X
X	if (fstat(fileno(file), buf) != 0)
X		ErrAbort("Bad fstat");
X	*temp = *getpwuid(buf->st_uid);
X	strcpy(ownersName, temp->pw_name);
X	return(ownersName);
X}
X
X
X/*
X * PORTABILITY WARNING:  The following routine is not very
X * portable, although it should work on most Unix systems.
X *
X * The following routine is intended to determine the user's
X * name.  This name will then be used as the file name which
X * holds the user's "stable storage" (machine key and stuff).
X * The most important thing to remember about this routine is
X * that THE TWO USER NAMES FOR TWO DIFFERENT USERS MUST BE
X * DIFFERENT.  If not, there will be a collision in the file
X * name space, with resulting chaos and confusion.
X */
Xvoid
XGetUserName(userName)
X	char	userName[MAX_USER_NAME_SIZE_IN_BYTES];
X{	struct passwd	temp[1];
X
X	*temp = *getpwuid(getuid());
X	if (strlen(temp->pw_name) >= MAX_USER_NAME_SIZE_IN_BYTES) {
X		fprintf(stderr, "User name \"%s\" is too long\n",
X			temp->pw_name);
X		ErrAbort("");
X	};
X	strcpy(userName, temp->pw_name);
X}
X
X/*
X * The following routine creates the public file name which
X * holds the public file entry.
X */
Xchar *
XMakePublicFileName(publicDirectoryName, publicKey)
X	char	*publicDirectoryName;
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X{	static	char	publicFileName[MAX_FILE_NAME_SIZE_IN_BYTES];
X	char	digits[50];
X	/*  public file entries are file names like:
X	 * publicDirectory/p361ad90c
X	 */
X	strcpy(publicFileName, publicDirectoryName);
X	(void) sprintf(digits, "/p%08lx_%08lx", publicKey[1], publicKey[2]);
X	strcat(publicFileName, digits);
X	return(publicFileName);
X};
X
X
X/*
X * The following routine creates the names of the two
X * "stable storage" files.
X */
Xvoid
XNameStableStorage(file1Name, file2Name)
X	char	file1Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	char	file2Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X{	char	userName[MAX_USER_NAME_SIZE_IN_BYTES];
X
X	strcpy(file1Name, STABLE1_DIRECTORY);
X	strcpy(file2Name, STABLE2_DIRECTORY);
X	strcat(file1Name, "/");
X	strcat(file2Name, "/");
X	GetUserName(userName);
X	if (5+strlen(file1Name)+strlen(userName)>=MAX_FILE_NAME_SIZE_IN_BYTES) {
X		fprintf(stderr, " File name \"%s%s\" too long\n",
X			file1Name, userName);
X		ErrAbort("");
X	};
X	if (5+strlen(file2Name)+strlen(userName)>=MAX_FILE_NAME_SIZE_IN_BYTES) {
X		fprintf(stderr, " File name \"%s%s\" too long\n",
X			file2Name, userName);
X		ErrAbort("");
X	};
X	strcat(file1Name, userName);
X	strcat(file2Name, userName);
X	strcat(file1Name, "1");
X	strcat(file2Name, "2");
X}
X
X/*
X * The following routine returns the file name after removing
X * any preceding directory names.  Example input:
X * "/usr/merkle/vorpal".  Example output: "vorpal"
X */
XGetFileSuffix(fileName, suffixName)
X	char	*fileName;
X	char	suffixName[MAX_FILE_NAME_SIZE_IN_BYTES];
X{	int	i;
X
X	i = strlen(fileName);
X	while( (fileName[i-1]!= '/') && (i > 0)) i--;
X	strcpy(suffixName, &fileName[i]);
X}
X
X
X/*
X * The following routine creates and returns the name of the
X * auxilliary information files.  Note that there are two
X * auxilliary file names, only one of which is in use at any
X * given time.  The one in use is selected by examining the
X * binary variable "toggle".  The use of two auxilliary file
X * names (used in a "ping-pong" fashion) eliminates timing problems
X * that can arise when the signing process fails to go to
X * a normal completion.
X */
Xchar *
XAuxInfoFile(toggle)
X	int	toggle;
X{	char	userName[MAX_USER_NAME_SIZE_IN_BYTES];
X	static	char file1Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	static	char file2Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	static	int  flag = 0;
X
X	if (flag == 0) {
X		flag = 1;
X		strcpy(file1Name, AUX_INFO_DIRECTORY);
X		strcpy(file2Name, AUX_INFO_DIRECTORY);
X		strcat(file1Name, "/");
X		strcat(file2Name, "/");
X		GetUserName(userName);
X		if (5+strlen(file1Name)+strlen(userName) >=
X			MAX_FILE_NAME_SIZE_IN_BYTES) {
X			fprintf(stderr, " File name \"%s%s\" too long\n",
X				file1Name, userName);
X			ErrAbort("");
X		};
X		if (5+strlen(file2Name)+strlen(userName) >=
X			MAX_FILE_NAME_SIZE_IN_BYTES) {
X			fprintf(stderr, " File name \"%s%s\" too long\n",
X				file2Name, userName);
X			ErrAbort("");
X		};
X		strcat(file1Name, userName);
X		strcat(file2Name, userName);
X		strcat(file1Name, "Aux0");
X		strcat(file2Name, "Aux1");
X		};
X	if (toggle==0)
X		return(file1Name);
X	else
X		return(file2Name);
X}
X
X/*
X * A simple error testing routine.  If the variable is not between
X * "low" and "high" inclusive, then print out the error message and
X * abort.
X */
Xvoid 
XRangeCheck (value, low, high, message)
X	int     value;
X	int     low;
X	int     high;
X	char   *message;
X{
X	if ((value < low) || (value > high)) {
X		fprintf(stderr, "Error: %s is %d which is outside [%d .. %d]\n",
X			message, value, low, high);
X		ErrAbort ("");
X	};
X}
X
X/* PORTABILITY WARNING:  This routine assumes that file names
X * use "/" to separate the directory names in a full path name.
X * The following routine creates the signature file name
X * given the file name.  Basically, if fileName is
X * /this/that/other/name
X * then the signature file is
X * /this/that/other/.JZname
X */
Xvoid
XmakeSigFileName(fileName, sigFileName)
X	char	*fileName;
X	char	sigFileName[MAX_FILE_NAME_SIZE_IN_BYTES];
X{	int	length;
X	int	slashLoc;
X	char	tempName[MAX_FILE_NAME_SIZE_IN_BYTES];
X
X	length = strlen(fileName);
X	if (length > MAX_FILE_NAME_SIZE_IN_BYTES-6) {
X		fprintf(stderr, "Signature file name \"%s\" too long.\n",
X			fileName);
X		ErrAbort("");
X	};
X	for(slashLoc = length-1; slashLoc >= 0; slashLoc--)
X		if(fileName[slashLoc] == '/') break;
X	strcpy(tempName, &fileName[slashLoc+1]);
X	strcpy(sigFileName, fileName);
X	sigFileName[slashLoc+1] = 0; /* terminate after the '/' */
X	strcat(sigFileName, ".");
X	strcat(sigFileName, SHORT_UNUSUAL_STRING);
X	strcat(sigFileName, tempName);
X}
X
X/**
X   The following rather awful computation determines how many
X   "counts" there should be.  Basically, its
X
X   securitySizeInBits / noOfBitsPerVerifier + fudgeFactor
X
X   where your really have to add and subtract 1's to make things
X   work out exactly right.  The fudgeFactor provides enough
X   additional counts to take care of the "check" field.
X
X   Examples:
X    for a 64-bit  word and 4 bits per verifier, we need 18 counts
X    for a 96-bit  word and 4 bits per verifier, we need 27 counts
X    for a 128-bit word and 4 bits per verifier, we need 35 counts
X    for a 64-bit  word and 8 bits per verifier, we need 10 counts
X
X*/
X
Xint 
XComputeNumberOfCounts (securitySize, wordSizeInBits, noOfBitsPerVerifier)
X	int     securitySize;
X	int     wordSizeInBits;
X	int     noOfBitsPerVerifier;
X{	int     noOfCounts;
X	word32 maxSumOfCounts;
X
X	noOfCounts = (wordSizeInBits * securitySize - 1) /
X		noOfBitsPerVerifier + 1;
X	/*
X	 * 1L << noOfBitsPerVerifier - 1 is really 2**noOfBitsPerVerifier-1
X	 */
X	maxSumOfCounts = noOfCounts * ((1L << noOfBitsPerVerifier) - 1);
X	noOfCounts += (SizeInBits (maxSumOfCounts) - 1) /
X		noOfBitsPerVerifier + 1;
X	return (noOfCounts);
X}
X
X/*
X * The following routine unpacks the 32-bits in "header" and
X * puts them into the specified output variables.
X * Yes, it would be nice to use bit fields, but there's
X * no guarantee that the bit fields would be laid out in
X * the same fashion from compiler to compiler.
X */
Xvoid
XUnPackHeader (	header, hashMethodPtr,
X		securitySizePtr, parameterSizePtr,
X		noOfBitsPerVerifierPtr, hashValueSizePtr, noOfCountsPtr)
X	word32 header;
X	int *hashMethodPtr;
X	int *securitySizePtr;
X	int *parameterSizePtr;
X	int *noOfBitsPerVerifierPtr;
X	int *hashValueSizePtr;
X	int *noOfCountsPtr;
X{	*hashMethodPtr = header >> 16;
X	*securitySizePtr = header>>8 & 0xf;
X	*parameterSizePtr = header>>4 & 0xf;
X	*noOfBitsPerVerifierPtr = header & 0xf;
X	*hashValueSizePtr = 2 * (*securitySizePtr);
X	*noOfCountsPtr = ComputeNumberOfCounts (*securitySizePtr,
X			   WORD_SIZE_IN_BITS, *noOfBitsPerVerifierPtr);
X	/*  range check everything */
X	switch (*hashMethodPtr) {
X		case SNEFRU4_METHOD:	break;
X		case MD4_METHOD:	break;
X		default:
X			ErrAbort("bad hash method");
X		};
X	RangeCheck (*securitySizePtr, 2, MAX_SECURITY_SIZE,
X		    "security size");
X	RangeCheck (*parameterSizePtr, 2, MAX_PARAMETER_SIZE,
X		    "parameter size");
X	RangeCheck (*noOfBitsPerVerifierPtr, 0, MAX_BITS_PER_VERIFIER,
X		    "bits per verifier");
X	RangeCheck (*noOfCountsPtr, 0, MAX_NO_OF_COUNTS,
X		    "number of counts");
X}
X
X/*
X * The following routine packs the given input variables
X * into *headerPtr.
X */
Xvoid
XPackHeader (	headerPtr, hashMethod,
X		securitySize, parameterSize, noOfBitsPerVerifier)
X	word32 *headerPtr;
X	int hashMethod;
X	int securitySize;
X	int parameterSize;
X	int noOfBitsPerVerifier;
X{	switch (hashMethod) {
X		case SNEFRU4_METHOD:	break;
X		case MD4_METHOD:	break;
X		default:
X			ErrAbort("bad hash method");
X		};
X	RangeCheck (securitySize, 2, MAX_SECURITY_SIZE,
X		    "security size");
X	RangeCheck (parameterSize, 2, MAX_PARAMETER_SIZE,
X		    "parameter size");
X	RangeCheck (noOfBitsPerVerifier, 0, MAX_BITS_PER_VERIFIER,
X		    "number of bits per verifier");
X
X	*headerPtr =	hashMethod << 16	|
X			securitySize << 8	|
X			parameterSize << 4	|
X			noOfBitsPerVerifier;
X}
X
X/*
X * The following routine computes the size of the public key
X * by examining the first word (32 bits) of the public key.
X * The first word encodes the hash method, the security size,
X * the parameter size, and other good stuff.  The size of
X * the public key in 32-bit words is just the security size
X * plus the parameter size plus 1 (the size of the 32-bit header).
X */
Xint
XComputePublicKeySize(publicKey)
Xword32 publicKey[MAX_PUBLIC_KEY_SIZE];
X{	int hashMethod;
X	int securitySize;
X	int parameterSize;
X	int noOfBitsPerVerifier;
X	int hashValueSize;
X	int noOfCounts;
X
X	if (publicKey[0] == 0) return(1);
X	UnPackHeader (	publicKey[0], &hashMethod,
X			&securitySize, &parameterSize,
X			&noOfBitsPerVerifier, &hashValueSize, &noOfCounts);
X	return(securitySize + parameterSize + 1);
X}
X
X/*
X * The following routine converts an array of word32 to a byte
X * array. It is primarily intended to eliminate the byte-ordering problem.
X * VAXes order the bytes in a character array differently than SUN's do. This
X * routine is not needed on SUNs (or other big-endian machines).
X */
Xvoid 
XConvertLongToChar (wordBuffer, charBuffer, wordLength)
X	word32	wordBuffer[ /* wordLength */ ];/* input buffer */
X	char    charBuffer[ /* wordLength * 4 */ ]; /* output buffer */
X	int	wordLength;
X{	int     i;
X	word32 temp;
X
X	for (i = 0; i < wordLength; i++) {
X		temp = wordBuffer[i];
X		charBuffer[4 * i + 0] = (temp >> 24) & 0xff;
X		charBuffer[4 * i + 1] = (temp >> 16) & 0xff;
X		charBuffer[4 * i + 2] = (temp >>  8) & 0xff;
X		charBuffer[4 * i + 3] = (temp >>  0) & 0xff;
X	};
X};
X
X/*
X * The following routine converts a byte array to an array of word32.
X * It is intended to eliminate the byte-ordering problem. VAXes order
X * the bytes in a character array differently than SUN's do.  Some
X * machines do REALLY horrible things -- this routine should be
X * fairly portable (if not blindingly fast).
X */
Xvoid 
XConvertBytes (buffer, wordBuffer, charCount)
X	char	buffer[];	/*  input buffer */
X	word32	wordBuffer[];	/*  output buffer */
X	int	charCount;
X{	int     i;
X	int     wordCount;
X	word32 t0, t1, t2, t3;
X
X	if (charCount <= 0) return;
X	wordCount = (charCount+3)>>2;
X	for (i = 0; i < wordCount; i++) {
X		t0 = buffer[4 * i + 0];
X		t1 = buffer[4 * i + 1];
X		t2 = buffer[4 * i + 2];
X		t3 = buffer[4 * i + 3];
X		t0 &= 0xff;
X		t1 &= 0xff;
X		t2 &= 0xff;
X		t3 &= 0xff;
X		wordBuffer[i] = (t0 << 24) | (t1 << 16) | (t2 << 8) | t3;
X	};
X	/* Get rid of the bottom bytes that aren't wanted */
X	switch (charCount&3) {
X		case 0:
X			break;
X		case 1:	wordBuffer[wordCount-1] &= 0xff000000L;
X			break;
X		case 2:	wordBuffer[wordCount-1] &= 0xffff0000L;
X			break;
X		case 3:	wordBuffer[wordCount-1] &= 0xffffff00L;
X	};
X}
X
X
X/*
X * The following routine increments a "path" location. This is a 32-bit word
X * that encodes a "path" up a binary tree.  Succeeding bits in the word
X * following the first "1" bit show whether to take the left or right branch
X * in the "path" from the root of the tree to any particular leaf.
X * 
X * When a "path" is incremented, it might overflow. In this case, the path value
X * is left unchanged and the routine returns the value "PATHOVERFLOW".
X * Otherwise the routine returns the value "NOPATHOVERFLOW"
X */
Xint 
XBumpPath (pathPtr)
X	word32 *pathPtr;
X{	/*
X	 * If the bit pattern passed in looks like: 000...00111....11
X	 * 
X	 * then, by definition, incrementing this by one causes an "overflow" in
X	 * the path description because it alters the location of the leading
X	 * "1" bit.
X	 */
X	if (SizeInBits (*pathPtr) != SizeInBits ((*pathPtr) + 1))
X		return (PATHOVERFLOW);
X	else {
X		(*pathPtr)++;
X		return (NOPATHOVERFLOW);
X	};
X}
X
X/*
X * The following routine sets a single bit in "array" at the designated
X * offset
X */
Xvoid 
XSetBit (array, bitOffset)
X	word32 array[];
X	int     bitOffset;
X{	int     wordOffset;
X	word32 mask;
X
X	/*
X	 * compute word and bit offsets for a 32-bit word size. Yes,
X	 * "WORD_SIZE_IN_BITS" is 32.  If not, watch out!
X	 */
X	wordOffset = bitOffset / WORD_SIZE_IN_BITS;
X	bitOffset %= WORD_SIZE_IN_BITS;
X	mask = 1;
X	mask <<= 31;		/* Set the topmost bit */
X	/* set the bit... */
X	array[wordOffset] |= (mask >> bitOffset);
X}
X
X/*
X * The following routine grabs noOfBits bits from the given array, at the
X * given bitOffset.  Bits beyond the array limit are defined to be 0
X */
Xword32 
XFetchBits (array, arrayLimit, bitOffset, noOfBits)
X	word32 array[ /* arrayLimit */ ];
Xint     arrayLimit;
Xint     bitOffset;
Xint     noOfBits;
X{	word32 temp1, temp2;
X	int     wordOffset;
X
X	/*
X	 * compute word and bit offsets for a 32-bit word size. Yes,
X	 * "WORD_SIZE_IN_BITS" is 32.  If not, watch out!
X	 */
X	wordOffset = bitOffset / WORD_SIZE_IN_BITS;
X	bitOffset %= WORD_SIZE_IN_BITS;
X
X
X	/* fetch the (possibly two) words involved from the array */
X	temp1 = array[wordOffset];
X	temp2 = array[wordOffset + 1];
X
X	/* check for references beyond array limit */
X	if (wordOffset >= arrayLimit)
X		temp1 = 0;
X	if (wordOffset + 1 >= arrayLimit)
X		temp2 = 0;
X
X
X	/* grab the bits from the right spot */
X	temp1 <<= bitOffset;
X	temp1 >>= WORD_SIZE_IN_BITS - noOfBits;
X
X	/* "or" in the bits from the second word, if needed */
X	if (bitOffset + noOfBits > WORD_SIZE_IN_BITS)
X		temp1 |= (temp2 >> (2 * WORD_SIZE_IN_BITS
X				- bitOffset - noOfBits));
X	/* and return the bits! */
X	return (temp1);
X}
X
Xvoid 
XDownLeft (p, n)
X	word32 p[ /* n */ ];
X	int     n;
X{	word32 overFlow;
X	int     temp;
X	int     i;
X
X	/* grab the bottom bit from the last word of the parameter */
X	overFlow = p[n - 1] & 1;
X	for (i = 0; i < n; i++) {
X		temp = p[i] & 1;
X		p[i] >>= 1;
X		p[i] |= overFlow << 31;
X		overFlow = temp;
X	};
X};
X
Xvoid 
XDownRight (p, n)
X	word32 p[ /* n */ ];
X{	word32 overFlow;
X	int     temp;
X	int     i;
X
X	/* grab the bottom bit from the last word of the parameter */
X	overFlow = p[n - 1] & 1;
X	overFlow ^= 1;		/* flip the bit */
X	for (i = 0; i < n; i++) {
X		temp = p[i] & 1;
X		p[i] >>= 1;
X		p[i] |= overFlow << 31;
X		overFlow = temp;
X	};
X};
X
Xvoid 
XUpRight (p, n)
X	word32 p[ /* n */ ];
X	int     n;
X{	word32 overFlow;
X	int     temp;
X	int     i;
X
X	/* Quick test for overflow  */
X	if ((p[0] >> (WORD_SIZE_IN_BITS - 4)) == 0)
X		ErrAbort (" Parameter overflow!");
X
X	/* grab the top bit from the first word of the parameter */
X	overFlow = (p[0] >> 31) & 1;
X	for (i = n - 1; i >= 0; i--) {
X		temp = (p[i] >> 31) & 1;
X		p[i] <<= 1;
X		p[i] |= overFlow;
X		overFlow = temp;
X	};
X};
X
Xvoid 
XUpLeft (p, n)
X	word32 p[ /* n */ ];
Xint     n;			/* length (in 32-bit words) of the parameter */
X{	word32 overFlow;
X	int     temp;
X	int     i;
X
X	/* Quick test for overflow  */
X	if ((p[0] >> (WORD_SIZE_IN_BITS - 4)) == 0)
X		ErrAbort (" Parameter overflow!");
X
X	/* grab the top bit from the first word of the parameter */
X	overFlow = (p[0] >> 31) & 1;
X	for (i = n - 1; i >= 0; i--) {
X		temp = (p[i] >> 31) & 1;
X		p[i] <<= 1;
X		p[i] |= overFlow;
X		overFlow = temp;
X	};
X	p[n - 1] ^= 1;		/* flip the bottom bit  */
X};
X
X
Xvoid 
XUpPath (p, parameterSize, path)
X	word32 p[];
X	word32 path;
X{	word32 reversePath;
X	int     pathLength;
X
X	if (path <= 0)
X		ErrAbort ("logic error -- path is not positive");
X	reversePath = 0;
X	/* First, reverse the bits  */
X	for (pathLength = -1; path != 0; pathLength++) {
X		reversePath <<= 1;
X		reversePath |= (path & 1);
X		path >>= 1;
X	};
X	/*
X	 * and throw away the bottom bit (which used to be the top bit)
X	 * because it's always 1
X	 */
X	reversePath >>= 1;
X
X	/* and go up the path!  */
X
X	while (pathLength != 0) {
X		if ((reversePath & 1) == 1)
X			UpLeft (p, parameterSize);
X		else
X			UpRight (p, parameterSize);
X		reversePath >>= 1;
X		pathLength--;
X	};
X}
X
Xvoid 
XHashThreeItems (out, outSize,
X		in1, in1Size,
X		in2, in2Size,
X		in3, in3Size,
X		hashMethod)
X	word32 out[];
X	int     outSize;
X	word32 in1[];
X	int     in1Size;
X	word32 in2[];
X	int     in2Size;
X	word32 in3[];
X	int     in3Size;
X	int     hashMethod;
X{	word32 tempIn[MAX_INPUT_BLOCK_SIZE];
X
X	if ((in1Size + in2Size + in3Size) > MAX_INPUT_BLOCK_SIZE)
X		ErrAbort ("Input to HashThreeItems is too large");
X	Copy (&tempIn[0], in1, in1Size);
X	Copy (&tempIn[in1Size], in2, in2Size);
X	Copy (&tempIn[in1Size + in2Size], in3, in3Size);
X	HashAny (out, outSize, tempIn, in1Size + in2Size + in3Size, hashMethod);
X};
X
Xvoid 
XHashTwoItems (out, outSize,
X	      in1, in1Size,
X	      in2, in2Size,
X	      hashMethod)
X	word32 out[];
X	int     outSize;
X	word32 in1[];
X	int     in1Size;
X	word32 in2[];
X	int     in2Size;
X	int     hashMethod;
X{	word32 empty[1];
X	HashThreeItems (out, outSize, in1, in1Size,
X		in2, in2Size, empty, 0, hashMethod);
X};
X
X/*
X * This routine increments a 64-bit counter by the given increment.
X */
Xvoid
XIncrement64BitCounter (counter, increment)
X	word32 counter[2];
X	long int increment;
X{	word32 maxInt = 0xffffffffL;
X
X	if ( (maxInt-counter[1]) < increment) {
X		/*  Overflow from the lower 32 bits  */
X		if (counter[0] == maxInt)
X			ErrAbort("64-bit counter overflowed");
X		/* bump the upper 32 bits  */
X		counter[0]++;
X		/* and then increment the lower 32 bits */
X		/* without ever overflowing! */
X		counter[1] = maxInt-counter[1];
X		counter[1] = increment - counter[1];
X	}
X	else
X	/* increment the total number of bits read */
X	counter[1] += increment;
X}
X
X/*  Read a "chunk" of "chunkSize" 32-bit words from the given
X *  file.  Take care of any byte ordering problems involved
X *  in reading the 32-bit input values
X */
Xint
XReadChunk (file, chunk, chunkSize)
X	FILE	*file;
X	word32	*chunk;
X	int	chunkSize;
X{	char	temp[4*SNEFRU_INPUT_BLOCK_SIZE];
X	int	byteCount;
X	int	i;
X
X	byteCount = fread(temp, 1, 4*chunkSize, file);
X	if (ferror(file) != 0) {
X		ErrAbort("Can't read from input file");
X	};
X	for (i=byteCount; i<4*chunkSize; i++)
X		temp[i] = 0;
X	ConvertBytes(temp, chunk, 4*chunkSize);
X	return(byteCount);
X}
X
Xvoid
XHashFile (inputFile, hashValue, hashValueSize, hashMethod)
X	FILE	*inputFile;
X	word32	hashValue[MAX_HASH_VALUE_SIZE];
X	int	hashValueSize;
X{	switch (hashMethod) {
X	case MD4_METHOD: 
X		Md4HashFile(inputFile, hashValue, hashValueSize);
X		break;
X	case SNEFRU4_METHOD:
X		SnefruHashFile(inputFile, hashValue, hashValueSize, hashMethod);
X		break;
X	};
X}
X
X/*  Write out information to one of the "stable storage files".
X *  The stable storage file is small, so it's kept in readable
X *  ASCII format.  This simplifies debugging, but makes the
X *  following routine more complex than a simple series of binary
X *  writes.
X */
Xvoid 
XWriteOneStableStorageFile (stableStorageFile,
X				machineKey,
X				publicKey,
X				hashedUserKey,
X				path,
X				top,
X				toggle,
X				OTTsize)
X	FILE	*stableStorageFile;
X	word32	machineKey[MACHINE_KEY_SIZE];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	hashedUserKey[HASHED_USER_KEY_SIZE];
X	word32	path[MAX_STACK_DEPTH];
X	int     top;
X	int	toggle;
X{	int     i;
X	int     printCode;
X	int	publicKeySize;
X
X	RangeCheck(top, 0, MAX_STACK_DEPTH-1, "top");
X	rewind(stableStorageFile);
X	printCode = fprintf (stableStorageFile, "machineKey =");
X	if (printCode <= 0)
X		ErrAbort ("can't write string to stable storage");
X	for (i = 0; i < MACHINE_KEY_SIZE; i++) {
X		printCode = fprintf (stableStorageFile,
X				" %08lx", machineKey[i]);
X		if (printCode <= 0)
X			ErrAbort ("bad write to stable storage");
X		if ((i % 4 == 3) && (MACHINE_KEY_SIZE - 1 > i))
X			printCode = fprintf (stableStorageFile,
X					"\n            ");
X		if (printCode <= 0)
X			ErrAbort ("bad string write to stable storage");
X	};
X	printCode = fprintf (stableStorageFile, "\nhashedUserKey =");
X	if (printCode <= 0)
X		ErrAbort ("can't write string to stable storage");
X	for (i = 0; i < HASHED_USER_KEY_SIZE; i++) {
X		printCode = fprintf (stableStorageFile,
X				" %08lx", hashedUserKey[i]);
X		if (printCode <= 0)
X			ErrAbort ("bad write to stable storage");
X		if ((i % 4 == 3) && (HASHED_USER_KEY_SIZE - 1 > i))
X			printCode = fprintf (stableStorageFile,
X					"\n            ");
X		if (printCode <= 0)
X			ErrAbort ("bad string write to stable storage");
X	};
X	printCode = fprintf (stableStorageFile, "\npublicKey  =");
X	if (printCode <= 0)
X		ErrAbort ("can't write string to stable storage");
X	publicKeySize = ComputePublicKeySize(publicKey);
X	for (i = 0; i < publicKeySize; i++) {
X		printCode = fprintf (stableStorageFile,
X				" %08lx", publicKey[i]);
X		if (printCode <= 0)
X			ErrAbort ("bad public key write to stable storage");
X	};
X	printCode = fprintf (stableStorageFile, "\ntoggle = %d\n", toggle);
X	if (printCode <= 0)
X		ErrAbort ("can't write toggle to stable storage");
X	printCode = fprintf (stableStorageFile, "OTTsize = %d\n", OTTsize);
X	if (printCode <= 0)
X		ErrAbort ("can't write OTTsize to stable storage");
X	printCode = fprintf (stableStorageFile, "top = %d\npath =", top);
X	if (printCode <= 0)
X		ErrAbort ("can't write top to stable storage");
X	for (i = 0; i <= top; i++) {
X		printCode = fprintf (stableStorageFile, " %lx", path[i]);
X		if (printCode <= 0)
X			ErrAbort ("bad path write to stable storage");
X	};
X	printCode = fprintf (stableStorageFile, "\n");
X	if (printCode <= 0)
X		ErrAbort ("can't write string to stable storage");
X}
X
X/*
X * The following routines write the machine key, the current signature
X * path, and the public key redundantly to two "stable storage" files.
X * Stable storage can be relied upon not to be changed, altered, or lost in
X * some unpleasant fashion.  As long as one of the two "stable storage" files
X * is intact, the aux info can be recovered.  If the two stable storage
X * files are kept on separate disk drives, then it is unlikely that both will
X * be lost simultaneously.
X * 
X * Stable storage should not be backed up.  If one stable storage file is
X * damaged, it should be re-initialized from the other stable storage file.
X * In the unlikely event that both stable storage files are damaged, then no
X * further messages should be signed with this signing key.  A new
X * signing-key/checking-key pair should be issued.
X * 
X * Note that loss of the secret signing key is a nuisance, but does not cause
X * any significant damage.  Messages already signed continue to be valid even
X * if the secret signing key is destroyed.  The newly issued secret signing
X * key can be used to sign new messages.  If interruption of service is an
X * issue, then a second signing-key/checking-key pair can be prepared for the
X * user in advance of need.  This will also provide uninterrupted service to
X * the user in case of other problems, such as theft, destruction, loss,
X * compromise, etc.
X * 
X * (Note that these precautions will prevent compromise of the machine
X * key and will also prevent re-signing of two different messages with
X * the same one-time signature.  The latter would seriously
X * jeopordize security).
X * 
X * Exactly how this "stable storage" is realized in any particular instance is
X * left up to the implementor.
X */
Xvoid 
XWriteStableStorage (file1, file2, machineKey,
X			publicKey, hashedUserKey,
X			path, top, toggle, OTTsize)
X	FILE	*file1;
X	FILE	*file2;
X	word32	machineKey[];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	hashedUserKey[HASHED_USER_KEY_SIZE];
X	word32	path[];
X	int     top;
X	int	toggle;
X	int	OTTsize;
X{	WriteOneStableStorageFile (file1, machineKey, publicKey,
X					hashedUserKey, path,
X					top, toggle, OTTsize);
X	WriteOneStableStorageFile (file2, machineKey, publicKey,
X					hashedUserKey, path,
X					top, toggle, OTTsize);
X};
X
X
X/*
X * The following two routines read the machine key and the path from stable
X * storage.  If the two files have conflicting values, abort at once.
X */
Xvoid 
XReadOneStableStorageFile (stableStorageFile, machineKey, publicKey,
X				hashedUserKey, path,
X				topPtr, togglePtr, OTTsizePtr)
X	FILE	*stableStorageFile;
X	word32	machineKey[MACHINE_KEY_SIZE];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	hashedUserKey[HASHED_USER_KEY_SIZE];
X	word32	path[MAX_STACK_DEPTH];
X	int	*topPtr;
X	int	*togglePtr;
X	int	*OTTsizePtr;
X{	int     i;
X	int     scanCode;
X	int	publicKeySize;
X
X	scanCode = fscanf (stableStorageFile, " machineKey = ");
X	if (scanCode != 0)
X		ErrAbort ("can't read string from stable storage");
X	for (i = 0; i < MACHINE_KEY_SIZE; i++) {
X		scanCode = fscanf (stableStorageFile, " %lx", &machineKey[i]);
X		if (scanCode != 1)
X			ErrAbort ("bad read from stable storage");
X	};
X	scanCode = fscanf (stableStorageFile, " hashedUserKey = ");
X	if (scanCode != 0)
X		ErrAbort ("can't read string from stable storage");
X	for (i = 0; i < HASHED_USER_KEY_SIZE; i++) {
X		scanCode = fscanf (stableStorageFile,
X			" %lx", &hashedUserKey[i]);
X		if (scanCode != 1)
X			ErrAbort ("bad read from stable storage");
X	};
X
X	/*  Read in the public key */
X	scanCode = fscanf (stableStorageFile, " publicKey = ");
X	if (scanCode != 0)
X		ErrAbort ("can't read string from stable storage");
X	scanCode = fscanf (stableStorageFile, " %lx", publicKey);
X	if (scanCode != 1)
X		ErrAbort ("bad path read from stable storage");
X	publicKeySize = ComputePublicKeySize(publicKey);
X	for (i = 1; i < publicKeySize; i++) {
X		scanCode = fscanf (stableStorageFile, " %lx", &publicKey[i]);
X		if (scanCode != 1)
X			ErrAbort ("bad path read from stable storage");
X	};
X
X	scanCode = fscanf (stableStorageFile,
X		" toggle = %d", togglePtr);
X	if (scanCode != 1)
X		ErrAbort (
X		"can't read toggle from stable storage");
X	RangeCheck(*togglePtr, 0, 1, "toggle");
X
X	scanCode = fscanf (stableStorageFile,
X		" OTTsize = %d", OTTsizePtr);
X	if (scanCode != 1)
X		ErrAbort (
X		"can't read OTTsize from stable storage");
X	RangeCheck(*OTTsizePtr, 4, MAX_OTT_SIZE, "OTT size");
X
X	scanCode = fscanf (stableStorageFile, " top = %d path =", topPtr);
X	if (scanCode != 1)
X		ErrAbort ("can't read top from stable storage");
X
X	if ((*topPtr) < 0)
X		ErrAbort ("top negative");
X	if ((*topPtr) >= MAX_STACK_DEPTH)
X		ErrAbort ("top too big");
X
X	for (i = 0; i <= *topPtr; i++) {
X		scanCode = fscanf (stableStorageFile, " %lx", &path[i]);
X		if (scanCode != 1)
X			ErrAbort ("bad path read from stable storage");
X	};
X}
X
X
X/*
X * Read the inputs from both files, and then compare them. If they disagree,
X * abort.
X */
Xvoid 
XReadStableStorage (file1, file2, machineKey, publicKey,
X			hashedUserKey, path, topPtr, togglePtr, OTTsizePtr)
X	FILE	*file1;
X	FILE	*file2;
X	word32	machineKey[MACHINE_KEY_SIZE];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	hashedUserKey[HASHED_USER_KEY_SIZE];
X	word32	path[MAX_STACK_DEPTH];
X	int	*topPtr;
X	int	*togglePtr;
X	int	*OTTsizePtr;
X{	word32	tempMachineKey[MACHINE_KEY_SIZE];
X	word32	tempPublicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	tempPath[MAX_STACK_DEPTH];
X	int	publicKeySize;
X	int	tempTop;
X	int	tempToggle;
X	int	tempOTTsize;
X	int	i;
X
X	ReadOneStableStorageFile (file1, machineKey, publicKey,
X		hashedUserKey, path, topPtr, togglePtr, OTTsizePtr);
X
X	ReadOneStableStorageFile (file2, tempMachineKey, tempPublicKey,
X		hashedUserKey, tempPath, &tempTop, &tempToggle, &tempOTTsize);
X
X	if (tempTop != (*topPtr))
X		ErrAbort ("conflicting stable storage for \"top\"");
X
X	if (tempToggle != (*togglePtr))
X	ErrAbort ("conflicting stable storage for \"toggle\"");
X
X	if (tempOTTsize!= (*OTTsizePtr))
X	ErrAbort ("conflicting stable storage for \"OTTsize\"");
X
X	for (i = 0; i < tempTop; i++)
X		if (tempPath[i] != path[i])
X			ErrAbort ("conflicting stable storage for path");
X
X	for (i = 0; i < MACHINE_KEY_SIZE; i++)
X		if (machineKey[i] != tempMachineKey[i])
X			ErrAbort ("conflicting stable storage for machine key");
X
X	publicKeySize = ComputePublicKeySize(publicKey);
X	for (i = 0; i < publicKeySize; i++)
X		if (publicKey[i] != tempPublicKey[i])
X			ErrAbort ("conflicting stable storage for public key");
X}
X
X/*
X * This routine reads in the data from the "signature file", which
X * is kept in binary, and then unpacks the data, performs range
X * checking, and generally converts the information in the file
X * into a useful internal format.
X */
Xvoid 
XReadSignature (sigFile,  hashMethodPtr,
X		noOfSignaturesPtr, parameter, parameterSizePtr,
X		securitySizePtr, hashValueSizePtr, noOfCountsPtr,
X		noOfBitsPerVerifierPtr, signature, locationPtr,
X		wordsToHashPtr, hashFromSig, dateTime32Ptr,
X		binaryDataFieldSizePtr, message)
X	FILE    *sigFile;
X	int	*hashMethodPtr;
X	int    *noOfSignaturesPtr;
X	word32 parameter[MAX_PARAMETER_SIZE];
X	int     *parameterSizePtr;
X	int	*securitySizePtr;
X	int	*hashValueSizePtr;
X	int	*noOfCountsPtr;
X	int	*noOfBitsPerVerifierPtr;
X	word32 signature[MAX_SIGNATURE_SIZE];
X	int    *locationPtr;
X	word32	*wordsToHashPtr;
X	word32	hashFromSig[MAX_HASH_VALUE_SIZE];
X	word32	*dateTime32Ptr;
X	int	*binaryDataFieldSizePtr;
X	char	message[MAX_MESSAGE_SIZE_IN_BYTES];
X{	int     lengthOfSignatureInBytes;
X	word32	*locInSig;
X	int	messageSize;
X	char    charSignature[MAX_SIGNATURE_SIZE * 4];
X
X	lengthOfSignatureInBytes =
X		fread (charSignature, 1,
X			MAX_SIGNATURE_SIZE * 4, sigFile);
X	if (ferror(sigFile) != 0) {
X		ErrAbort("Can't read from signature file");
X	};
X	ConvertBytes (charSignature, signature, MAX_SIGNATURE_SIZE * 4);
X	/* dull error tests */
X	RangeCheck (lengthOfSignatureInBytes, 0, MAX_SIGNATURE_SIZE * 4,
X		"Signature length");
X	if (lengthOfSignatureInBytes % 4 != 0)
X		ErrAbort ("Signature length not a multiple of 4 bytes");
X	/* We've read in the signature file */
X
X	locInSig = signature;
X	/*  now unpack the header */
X	UnPackHeader( *locInSig, hashMethodPtr,
X		securitySizePtr, parameterSizePtr,
X		noOfBitsPerVerifierPtr, hashValueSizePtr, noOfCountsPtr);
X	/*
X	 * return the number of one-time signatures used in this
X	 * signature
X	 */
X	locInSig++;
X	*noOfSignaturesPtr = (*locInSig) & 0xff;
X	*wordsToHashPtr = (*locInSig)>>16;
X	*binaryDataFieldSizePtr = ((*locInSig)>>8) & 0xff;
X	locInSig++;
X	*dateTime32Ptr = *locInSig;
X	locInSig++;
X	Copy(hashFromSig, locInSig, *hashValueSizePtr);
X	locInSig += *hashValueSizePtr;
X	Copy(parameter, locInSig, *parameterSizePtr);
X	locInSig += *parameterSizePtr;
X	messageSize = *wordsToHashPtr - *binaryDataFieldSizePtr-2;
X	if (messageSize >= MAX_MESSAGE_SIZE-4)
X		ErrAbort("Message size in signature is too big");
X	ConvertLongToChar(locInSig, message, messageSize);
X	locInSig += messageSize;
X
X	/*
X	 * compute the start of the one-time signature count verifier block
X	 */
X	*locationPtr = locInSig - signature;
X};
X
X
X/*
X * This routine checks an authentication path
X */
Xvoid 
XCheckAuthenticationPath (checkValue, securitySize,
X			 parameter, parameterSize,
X			 hashMethod,
X			 path,
X			 branchVerifiers)
X	word32 checkValue[];
X	int     securitySize;
X	word32 parameter[];
X	int     parameterSize;
X	int     hashMethod;
X	word32 path;
X	word32 branchVerifiers[];
X{	while (path != 1) {
X		if ((path & 1) == 1) {
X
X#if DEBUG
X			printf ("auth path bit is 1\n");
X			PrintIt ("branchVerifiers=",
X				 branchVerifiers, securitySize);
X			PrintIt ("checkValue=", checkValue, securitySize);
X			PrintIt ("parameter=", parameter, parameterSize);
X#endif
X			DownRight (parameter, parameterSize);
X
X			HashThreeItems (checkValue, securitySize,
X					branchVerifiers, securitySize,
X					checkValue, securitySize,
X					parameter, parameterSize,
X					hashMethod);
X		} else {
X
X#if DEBUG
X			printf ("auth path bit is 0\n");
X			PrintIt ("checkValue=", checkValue, securitySize);
X			PrintIt ("branchVerifiers=",
X				 branchVerifiers, securitySize);
X			PrintIt ("parameter=", parameter, parameterSize);
X#endif
X
X			DownLeft (parameter, parameterSize);
X
X			HashThreeItems (checkValue, securitySize,
X					checkValue, securitySize,
X					branchVerifiers, securitySize,
X					parameter, parameterSize,
X					hashMethod);
X		};
X		path >>= 1;
X		branchVerifiers += securitySize;
X	};
X}
X
X/*
X * The following routine accepts as input a public key
X * (normally computed from a signature) and the name
X * of the public directory.  It looks up the public key
X * in the public directory.  It returns 0 if the search was
X * successful, and sets "userName" to the name found in
X * the public directory.  It returns non-zero if the search
X * was unsuccessful, and userName is left empty ("");
X *
X */
Xint 
XLookUpPublicKey (publicKey, publicDirectoryName, userName)
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE]; /* Input */
X	char	*publicDirectoryName;
X	char	userName[MAX_USER_NAME_SIZE_IN_BYTES]; /* Output */
X{	char	*publicFileName;
X	word32	tempPublicKey[MAX_PUBLIC_KEY_SIZE];
X	int     i;
X	int	publicKeySize;
X	int	scanReturnCode;
X	FILE	*publicFile;
X	char	*ownersName;
X	char	tempName[MAX_USER_NAME_SIZE_IN_BYTES];
X
X	/* open the "public file" entry, read only */
X	publicFileName = MakePublicFileName(publicDirectoryName, publicKey);
X	publicFile = fopen (publicFileName, "r");
X	userName[0] = (char) 0;
X	if (publicFile == NULL)
X		return(-1);
X	ownersName = FileOwnersName(publicFile);
X	scanReturnCode = fscanf (publicFile,
X		/* WARNING:
X		 * update constant 300 when MAX_USER_NAME_SIZE_IN_BYTES
X		 * is changed.  Updating this constant is required
X		 * to correctly prevent overflow if the public file
X		 * has a name which is too long.
X		 */
X		"%*[^#]#%300[^:]: %lx", tempName, tempPublicKey);
X	if (scanReturnCode == 0) /*  didn't scan the "#" */
X		scanReturnCode = fscanf (publicFile,
X			/* WARNING: update constant 300 when
X			 * MAX_USER_NAME_SIZE_IN_BYTES is changed.
X			 */
X			"#%300[^:]: %lx", tempName, tempPublicKey);
X	if(scanReturnCode != 2)
X		return(-1);
X	publicKeySize = ComputePublicKeySize(tempPublicKey);
X	for (i = 1; i < publicKeySize; i++) {
X		scanReturnCode = fscanf(publicFile, " %lx", &tempPublicKey[i]);
X		if (scanReturnCode != 1)
X			return(-1);
X		};
X	for (i = 0; i < publicKeySize; i++)
X		if (publicKey[i] != tempPublicKey[i])
X			return(-1);
X	FileClose (publicFile, publicFileName);
X	if ( (strlen(tempName)+strlen(ownersName)) >=
X		MAX_USER_NAME_SIZE_IN_BYTES-4) {
X		fprintf(stderr,
X			"String: \"%s:%s\" is longer than %d bytes\n",
X			ownersName, tempName, MAX_USER_NAME_SIZE_IN_BYTES);
X		ErrAbort("");
X	};
X	strcpy(userName, ownersName);
X	strcat(userName, ":");
X	strcat(userName, tempName);
X	return(0);
X}
X
X/*
X * The following routine creates/checks a one-time signature.  Note
X * that the routine can be used both to sign and to check a value to
X * sign.
X */
Xvoid 
XOneTimeSignCheck (valueToSign, securitySize,
X		  parameter, parameterSize, signCheckFlag,
X		  noOfCounts, bitsPerVerifier,
X		  xyVector, hashForSignature, hashMethod)
X	word32 valueToSign[ /* securitySize */ ];
X	int     securitySize;
X	word32 parameter[MAX_PARAMETER_SIZE];
X	int     parameterSize;
X	int     signCheckFlag;
X	word32 xyVector[MAX_NO_OF_COUNTS * MAX_SECURITY_SIZE];
X	word32 hashForSignature[MAX_SECURITY_SIZE];
X	int     hashMethod;
X{	int     i, j;
X	word32	count[MAX_NO_OF_COUNTS];
X	word32	twoToTheBitsPerVerifier;
X	int     bitsNeeded;
X	word32	parameterLastWord;
X
X	twoToTheBitsPerVerifier = 1;
X	twoToTheBitsPerVerifier <<= bitsPerVerifier;
X
X
X	/* compute the counts  */
X	for (i = 0; i < noOfCounts; i++)
X		count[i] =
X			FetchBits (valueToSign, securitySize,
X				   i * bitsPerVerifier, bitsPerVerifier);
X
X
X	/*
X	 * The valueToSign has some bits in it.  We need to pad out this
X	 * array with a "check" field to prevent tampering with the count
X	 * values by evil doers
X	 */
X	FillInTheCheckField (count, noOfCounts,
X			     securitySize, bitsPerVerifier,
X			     twoToTheBitsPerVerifier);
X	/*
X	 * Okay, we've spread the bits out into the array "count" and also
X	 * added the check field to the array "count"
X	 */
X	/*
X	 * Compute the number of bits needed for the combined count and the
X	 * bitsPerVerifier in the parameter
X	 */
X	bitsNeeded = SizeInBits ((word32)
X				 noOfCounts * twoToTheBitsPerVerifier);
X	/* and make room for that many bits in the parameter */
X	for (i = 0; i < bitsNeeded; i++)
X		UpRight (parameter, parameterSize);
X	/*
X	 * Remember the last word of the parameter -- we diddle it to
X	 * parameterize each application of hashN for the one time signature
X	 */
X	parameterLastWord = parameter[parameterSize - 1];
X	/* zero out the hash value result for the signature  */
X	for (i = 0; i < securitySize; i++)
X		hashForSignature[i] = 0;
X	for (i = 0; i < noOfCounts; i++) {
X		/* hash down the sequence */
X		if (signCheckFlag != CHECK) {
X			for (j = twoToTheBitsPerVerifier - 1;
X					j > count[i]; j--) {
X				/* tweak the parameter for <i,j> */
X				parameter[parameterSize - 1] =
X					parameterLastWord ^
X					(i * twoToTheBitsPerVerifier + j);
X				HashTwoItems (&xyVector[i * securitySize],
X					securitySize,
X					&xyVector[i * securitySize],
X					securitySize,
X					parameter, parameterSize,
X					hashMethod);
X			};
X		};
X		/* keep hashing  */
X		if (signCheckFlag != SIGN) {
X			for (j = count[i]; j > 0; j--) {
X				parameter[parameterSize - 1] =
X					parameterLastWord ^
X					(i * twoToTheBitsPerVerifier + j);
X				HashTwoItems (&xyVector[i * securitySize],
X					securitySize,
X					&xyVector[i * securitySize],
X					securitySize,
X					parameter, parameterSize,
X					hashMethod);
X			};
X			parameter[parameterSize - 1] = parameterLastWord ^
X				(i * twoToTheBitsPerVerifier);
X			HashThreeItems (hashForSignature, securitySize,
X					hashForSignature, securitySize,
X					&xyVector[i * securitySize],
X					securitySize,
X					parameter, parameterSize,
X					hashMethod);
X		};
X	};
X	/* Restore the parameter  */
X	parameter[parameterSize - 1] = parameterLastWord;
X	for (i = 0; i < bitsNeeded; i++)
X		DownLeft (parameter, parameterSize);
X}
X
X
X/*
X * The following routine hashes the input file, compares this
X * with the hash stored in the signature (to verify they are
X * equal), then re-computes the public key using the provided
X * authentication information, and finally returns the computed
X * public key.
X */
XCheck(inputFile, sigFile, publicKey, dateTime32Ptr, msgBuffer)
X	FILE	*inputFile;
X	FILE	*sigFile;
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	*dateTime32Ptr;
X	char	msgBuffer[MAX_MESSAGE_SIZE_IN_BYTES];
X{	int     location;
X	word32	pathDescription;
X	int     signatures;
X	word32	outputCheckValue[MAX_SECURITY_SIZE];
X	int     hashMethod;
X	int     securitySize;
X	int     hashValueSize;
X	word32	hashValue[MAX_HASH_VALUE_SIZE];
X	int     noOfCounts;
X	int     noOfSignatures;
X	int     noOfBitsPerVerifier;
X	word32	parameter[MAX_PARAMETER_SIZE];
X	word32	checkValue[MAX_SECURITY_SIZE];
X	int     parameterSize;
X	word32	signature[MAX_SIGNATURE_SIZE];
X	int	i;
X	word32	hashFromSig[MAX_HASH_VALUE_SIZE];
X	word32	*hashPtr;
X	int	chunkSize;
X	word32	wordsToHash;
X	int	binaryDataFieldSize;
X#if SHOW_TIMES
X	word32	startTime, stopTime;
X	int	signRepeatIndex;
X	double	signTime;
X#endif
X
X	/* self-test, to make sure everything is okay.  */
X	DoSelfTest (SELF_TEST);
X	/* Check the digitally signed message  */
X
X#if SHOW_TIMES
X	startTime = GetCpuTime();
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X#endif
X	ReadSignature (sigFile, &hashMethod,
X			&noOfSignatures, parameter, &parameterSize,
X			&securitySize, &hashValueSize, &noOfCounts,
X			&noOfBitsPerVerifier, signature, &location,
X			&wordsToHash, hashFromSig, dateTime32Ptr,
X			&binaryDataFieldSize, msgBuffer);
X
X	HashFile (inputFile, hashValue, hashValueSize, hashMethod);
X	for (i=0; i<hashValueSize; i++)
X		if (hashValue[i] != hashFromSig[i])
X			ErrAbort("File or signature has been changed");
X	hashPtr = signature;
X	for (i=0; i<hashValueSize; i++) hashValue[i] = 0;
X	i = wordsToHash;
X	chunkSize = INPUT_BLOCK_SIZE-hashValueSize;
X	while (i >= chunkSize) {
X		HashTwoItems(hashValue, hashValueSize,
X			hashValue, hashValueSize,
X			hashPtr, chunkSize, hashMethod);
X		hashPtr += chunkSize;
X		i -= chunkSize;
X	};
X	if (i>0)  HashTwoItems(hashValue, hashValueSize,
X			hashValue, hashValueSize,
X			hashPtr, i, hashMethod);
X	HashTwoItems(hashValue, hashValueSize,
X		hashValue, hashValueSize,
X		&wordsToHash, 1, hashMethod);
X#if DEBUG
X	PrintIt ("hashValue=", hashValue, hashValueSize);
X	PrintIt ("parameter=", parameter, parameterSize);
X#endif
X	/* initialize checkValue */
X	HashTwoItems (checkValue, securitySize,
X		      hashValue, hashValueSize,
X		      parameter, parameterSize,
X		      hashMethod);
X	for (signatures = 0; signatures < noOfSignatures; signatures++) {
X		/* Set parameter for one-time signature  */
X		DownLeft (parameter, parameterSize);
X		UpLeft (parameter, parameterSize);
X#if DEBUG
X		printf ("\nAbout to check one time signature\n");
X		PrintIt ("checkValue=", checkValue, securitySize);
X		PrintIt ("parameter=", parameter, parameterSize);
X#endif
X		OneTimeSignCheck (checkValue, securitySize,
X				  parameter, parameterSize, CHECK,
X				  noOfCounts, noOfBitsPerVerifier,
X		     &signature[location], outputCheckValue, hashMethod);
X		Copy (checkValue, outputCheckValue, securitySize);
X#if DEBUG
X		printf ("\nfinished checking one time signature\n");
X		PrintIt ("checkValue=", checkValue, securitySize);
X		PrintIt ("parameter=", parameter, parameterSize);
X#endif
X		location += securitySize * noOfCounts;
X		pathDescription = signature[location];
X		location++;	/* skip the path description */
X		DownRight (parameter, parameterSize);
X		CheckAuthenticationPath (checkValue, securitySize, parameter,
X					 parameterSize, hashMethod,
X					 pathDescription, &signature[location]);
X		/* now skip past the authentication path */
X		location -= securitySize;	/* fix off-by-one error */
X		while (pathDescription != 0) {
X			pathDescription >>= 1;
X			location += securitySize;
X		};
X	};
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds to read and check signature\n",
X		signTime);
X#endif
X#if DEBUG
X	printf ("about to print results\n");
X	PrintIt ("checkValue=", checkValue, securitySize);
X	PrintIt ("parameter=", parameter, parameterSize);
X#endif
X#if SHOW_TIMES
X	startTime = GetCpuTime();
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X#endif
X	publicKey[0] = signature[0];
X	Copy(&publicKey[1], checkValue, securitySize);
X	Copy(&publicKey[1+securitySize], parameter, parameterSize);
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds for look up in public file\n",
X		signTime);
X#endif
X}
X
X/*
X * The following routine dumps a signature in a readable format.
X */
Xvoid 
XDumpSig(sigFile)
X	FILE	*sigFile;
X{	int     location;
X	word32	pathDescription;
X	int     signatures;
X	int     hashMethod;
X	int     securitySize;
X	int     hashValueSize;
X	int     noOfCounts;
X	int     noOfSignatures;
X	int     noOfBitsPerVerifier;
X	word32	parameter[MAX_PARAMETER_SIZE];
X	int     parameterSize;
X	word32	signature[MAX_SIGNATURE_SIZE];
X	int	i;
X	int	j;
X	word32	dateTime32;
X	char	message[MAX_MESSAGE_SIZE_IN_BYTES];
X	word32	hashFromSig[MAX_HASH_VALUE_SIZE];
X	word32	wordsToHash;
X	int	binaryDataFieldSize;
X	long	longTemp;
X	char	dateString[80];
X
X	ReadSignature (sigFile, &hashMethod,
X			&noOfSignatures, parameter, &parameterSize,
X			&securitySize, &hashValueSize, &noOfCounts,
X			&noOfBitsPerVerifier, signature, &location,
X			&wordsToHash, hashFromSig, &dateTime32,
X			&binaryDataFieldSize, message);
X
X	printf(" hash method             = %d\n", hashMethod);
X	printf(" number of counts        = %d\n", noOfCounts);
X	printf(" no of bits per verifier = %d\n", noOfBitsPerVerifier);
X	printf(" number of signatures    = %d\n", noOfSignatures);
X	printf(" location of first sig   = %d\n", location);
X	longTemp = dateTime32;
X	strcpy(dateString, ctime(&longTemp));
X	if (dateString[strlen(dateString)-1] == '\n')
X		dateString[strlen(dateString)-1] = (char) 0;
X	printf(" date of signature       = %s\n", dateString);
X	printf(" message                 = \"%s\"\n", message);
X	printf(" words to hash           = %d\n", wordsToHash);
X	printf(" binary data field size  = %d\n", binaryDataFieldSize);
X	printf(" security size           = %d\n", securitySize);
X	printf(" parameter size          = %d\n", parameterSize);
X	printf(" parameter               =");
X	for (i=0; i<parameterSize; i++)
X		printf(" %08lx", parameter[i]);
X	printf("\n hash value size         = %d\n", hashValueSize);
X	printf(" hash value              =");
X	for (i=0; i<hashValueSize; i++)
X		printf(" %08lx", hashFromSig[i]);
X	printf("\n\n");
X	
X
X	for (signatures = 0; signatures < noOfSignatures; signatures++) {
X		printf("\n authenticators:\n");
X		for (i=0; i<noOfCounts; i++) {
X			printf("          ");
X			for (j=0; j<securitySize; j++) {
X				printf(" %08lx",
X					signature[location+i*securitySize+j]);
X			};
X			printf("\n");
X		};
X		location += securitySize * noOfCounts;
X		pathDescription = signature[location];
X		printf("\n path description        = %08lx\n", pathDescription);
X		location++;	/* skip the path description */
X		/* now skip past the authentication path */
X		if (pathDescription != 0) while (pathDescription != 1) {
X			printf("     ");
X			for (i=0; i<securitySize; i++)
X				printf(" %08lx", signature[location+i]);
X			printf("\n");
X			pathDescription >>= 1;
X			location += securitySize;
X		};
X	};
X}
X
X
X
X/* The signing routines follow this point  */
X
X
X/* The following routine emptys the signature buffer  */
X/* All it does is set the "next available word" pointer  */
X/* to 0 */
Xvoid 
XEmptySignatureBuffer (sigBuffer)
X	struct SIG_BUF *sigBuffer;
X{
X	sigBuffer->locInSignature = 0;
X}
X
X/* Places the passed in array into the signature buffer.  */
Xvoid 
XPutInSignatureBuffer (array, size, sigBuffer)
X	word32 array[];
X	int     size;
X	struct SIG_BUF *sigBuffer;
X{	int     i;
X
X	if (sigBuffer->locInSignature + size >= MAX_SIGNATURE_SIZE)
X		ErrAbort (" overflow of authentication path");
X	for (i = 0; i < size; i++)
X		sigBuffer->signature[sigBuffer->locInSignature + i] = array[i];
X	sigBuffer->locInSignature += size;
X}
X
Xvoid 
XGenPathForOTT (depth, top, securitySize, noOfCounts,
X		path, countVerifiers,
X		authPathValues,
X		sigBuffer)
X	int     depth;
X	int     top;
X	int     securitySize;
X	int     noOfCounts;
X	word32 path[MAX_STACK_DEPTH];
X	word32 countVerifiers
X		[MAX_STACK_DEPTH]
X		[MAX_NO_OF_COUNTS]
X		[MAX_SECURITY_SIZE];
X	word32 authPathValues
X		[MAX_STACK_DEPTH]
X		[2 * MAX_OTT_SIZE]
X		[MAX_SECURITY_SIZE];
X	struct SIG_BUF *sigBuffer;
X{	int     i;
X	word32 temp;
X
X	/* spit out the count verifiers  */
X	if (depth < top)
X		for (i = 0; i < noOfCounts; i++) {
X#if DEBUG
X			PrintIt ("countVerifier=",
X				 countVerifiers[depth + 1][i], securitySize);
X#endif
X			PutInSignatureBuffer (countVerifiers[depth + 1][i],
X					      securitySize, sigBuffer);
X		};
X
X	/* and the path description */
X#if DEBUG
X	PrintIt ("path=", &path[depth], 1);
X#endif
X	PutInSignatureBuffer (&path[depth], 1, sigBuffer);
X
X	/* and then the authentication path */
X	temp = path[depth];
X	for (temp = path[depth]; temp != 1; temp >>= 1) {
X#if DEBUG
X		PrintIt ("authPathValue=",
X		   authPathValues[depth][temp ^ 1], securitySize);
X#endif
X		PutInSignatureBuffer (authPathValues[depth][temp ^ 1],
X				      securitySize, sigBuffer);
X	};
X}
X
Xvoid 
XGenerateAuthenticationPath (top, securitySize,
X			    noOfCounts,
X			    path, countVerifiers,
X			    authPathValues, sigBuffer)
X	int     top;
X	int     securitySize;
X	int     noOfCounts;
X	word32 path[MAX_STACK_DEPTH];
X	word32 countVerifiers
X		[MAX_STACK_DEPTH]
X		[MAX_NO_OF_COUNTS]
X		[MAX_SECURITY_SIZE];
X	word32 authPathValues
X		[MAX_STACK_DEPTH]
X		[2 * MAX_OTT_SIZE]
X		[MAX_SECURITY_SIZE];
X	struct SIG_BUF *sigBuffer;
X{	int     depth;
X	for (depth = top; depth >= 0; depth--)
X		GenPathForOTT (depth,
X				top, securitySize,
X				noOfCounts, path,
X		       countVerifiers, authPathValues, sigBuffer);
X}
X
X/*
X * Read in the information from the auxilliary file (which is stored
X * in binary) and convert it into some useful internal format.
X */
Xvoid 
XReadBinaryAuxInfo (top, securitySize, noOfCounts, OTTsize, authPathValues,
X	countVerifiers, toggle)
X	int     top;
X	int	securitySize;
X	int	noOfCounts;
X	int	OTTsize;
X	word32	authPathValues
X		[MAX_STACK_DEPTH]
X		[2 * MAX_OTT_SIZE]
X		[MAX_SECURITY_SIZE];
X	word32	countVerifiers
X		[MAX_STACK_DEPTH]
X		[MAX_NO_OF_COUNTS]
X		[MAX_SECURITY_SIZE];
X	int	toggle;
X{	int	readReturnCode;
X	FILE	*auxInfoFile;
X	int	i,j,k,loc;
X	word32	temp[MAX_STACK_DEPTH*MAX_SECURITY_SIZE*2*MAX_OTT_SIZE];
X
X
X	if (2*MAX_OTT_SIZE < MAX_NO_OF_COUNTS)
X		ErrAbort("2*MAX_OTT_SIZE < MAX_NO_OF_COUNTS");
X	RangeCheck (top, 0, MAX_STACK_DEPTH - 1, "top");
X	auxInfoFile = fopen (AuxInfoFile(toggle), "rb");
X	if (auxInfoFile == NULL)
X		ErrAbort ("Can't open aux info file for read");
X	readReturnCode = fread((char*)temp, 1,
X		top*noOfCounts*securitySize*sizeof(word32), auxInfoFile);
X	if (readReturnCode !=
X		top*noOfCounts*securitySize*sizeof(word32)) {
X		fprintf(stderr,
X			"Can't read verifiers from %s\n", AuxInfoFile(toggle));
X		exit(1);
X	};
X	loc = 0;
X	for(i=1; i<=top; i++)
X	for(j=0; j<noOfCounts; j++)
X	for(k=0; k<securitySize; k++)
X		countVerifiers[i][j][k] = temp[loc++];
X
X
X	readReturnCode = fread((char*)temp, 1,
X		(top+1)*2*OTTsize*securitySize*sizeof(word32), auxInfoFile);
X	if (readReturnCode!=
X		(top+1)*2*OTTsize*securitySize*sizeof(word32)) {
X		fprintf(stderr,
X			"Can't read authPathValues from %s\n",
X				AuxInfoFile(toggle));
X		exit(1);
X	};
X	loc = 0;
X	for(i=0; i<=top; i++)
X	for(j=0; j<2*OTTsize; j++)
X	for(k=0; k<securitySize; k++)
X		 authPathValues[i][j][k] = temp[loc++];
X
X	FileClose(auxInfoFile, AuxInfoFile(toggle));
X}
X
X/* Generate pseudo-random "secret X values" and put them into
X * "xyVector".  The number of elements in "xyVector" is given
X * by "elementsInXVector", while the size of each element
X * (which will typically be 2, the normal size for securitySize)
X * is given by "sizeOfXYElementInWords".  The two inputs, "bits1"
X * and "bits2" hold the "seed" information from which to generate
X * the pseudo-random secret X values.
X */
Xvoid 
XGenerateSecretXValues (
X		       xyVector, elementsInXVector, sizeOfXYElementInWords,
X		       bits1, sizeOfBits1,
X		       bits2, sizeOfBits2,
X		       hashMethod)
X	word32 xyVector[MAX_NO_OF_COUNTS * MAX_SECURITY_SIZE];
X	int     elementsInXVector;
X	int     sizeOfXYElementInWords;
X	word32 bits1[];
X	int     sizeOfBits1;
X	word32 bits2[];
X	int     sizeOfBits2;
X	int     hashMethod;
X{	int     i;
X	word32 tempBlock[MAX_INPUT_BLOCK_SIZE];
X
X	/*  Error checking  */
X	if (sizeOfBits1+sizeOfBits2 > MAX_INPUT_BLOCK_SIZE)
X		ErrAbort("Input size too large to generate xyVector");
X	/* zero out the tempBlock bits  */
X	for (i = 0; i < MAX_INPUT_BLOCK_SIZE; i++)
X		tempBlock[i] = 0;
X	/*  and copy the bits to tempBlock  */
X	Copy( tempBlock,		bits1, sizeOfBits1);
X	Copy(&tempBlock[sizeOfBits1],	bits2, sizeOfBits2);
X	/*
X	 * generate some secret random bits by hashing together the input
X	 * bits, and putting them in xyVector.
X	 */
X	HashExpand (xyVector, elementsInXVector * sizeOfXYElementInWords,
X			tempBlock, sizeOfBits1+sizeOfBits2, hashMethod);
X}
X
X
X/*
X * The following routine takes a set of counts in the array "count,"
X * determines how big the "check" field should be, and how many elements near
X * the end of the "count" array it should occupy, computes the "check" field
X * and appends the needed bits to the end of "count"
X */
XFillInTheCheckField (count, noOfCounts,
X		     securitySize, bitsPerVerifier,
X		     twoToTheBitsPerVerifier)
X	word32 count[ /* noOfCounts */ ];
X	int     noOfCounts;
X	int     securitySize;
X	int     bitsPerVerifier;
X	word32 twoToTheBitsPerVerifier;
X{	word32 sumOfCounts;
X	word32 maxPossibleSumOfCounts;
X	int     startOfCheckFieldInCountArray;
X	int     sizeOfCheckFieldInBits;
X	int     checkFieldCounts;
X	int     startOfCheckFieldInBits;
X	int     i;
X
X	/*
X	 * figure out where the check field starts (the offset in the "count"
X	 * array)
X	 */
X	startOfCheckFieldInCountArray =
X		(WORD_SIZE_IN_BITS * securitySize - 1) / bitsPerVerifier + 1;
X	/* compute the maximum possible sum of counts  */
X	maxPossibleSumOfCounts = startOfCheckFieldInCountArray *
X		(twoToTheBitsPerVerifier - 1);
X	/*
X	 * figure out how many bits are in the check field by seeing how many
X	 * bits it takes to hold the maximum possible sum of counts
X	 */
X	sizeOfCheckFieldInBits = SizeInBits (maxPossibleSumOfCounts);
X	/* and figure out how many counts that takes  */
X	checkFieldCounts = (sizeOfCheckFieldInBits - 1) / bitsPerVerifier + 1;
X	/* make sure the check field will fit!  */
X	if (startOfCheckFieldInCountArray + checkFieldCounts != noOfCounts)
X		ErrAbort ("adjust noOfCounts");
X
X	/* There shouldn't be anything in the check field right now  */
X	for (i = startOfCheckFieldInCountArray; i < noOfCounts; i++)
X		if (count[i] != 0)
X			ErrAbort ("Undefined check field");
X	/* add up the total value of the counts  */
X	sumOfCounts = 0;
X	for (i = 0; i < noOfCounts; i++)
X		sumOfCounts += count[i];
X	/* and reverse it  */
X	sumOfCounts = maxPossibleSumOfCounts - sumOfCounts;
X	/* figure out where the bits start  */
X	startOfCheckFieldInBits = WORD_SIZE_IN_BITS -
X			checkFieldCounts * bitsPerVerifier;
X	/*
X	 * The following is not intrinsically wrong -- I'm just not going to
X	 * bother handling a check field bigger than 32 bits.  I figure it
X	 * should never happen....
X	 */
X	if (startOfCheckFieldInBits <= 0)
X		ErrAbort ("Check field overflowed 32 bits");
X	/*
X	 * Okay, now we know the start and size of the "check" field, grab
X	 * the bits and put them into the "count" array at the proper spot
X	 */
X	for (i = startOfCheckFieldInCountArray; i < noOfCounts; i++) {
X		count[i] = FetchBits (&sumOfCounts, 1,
X				  startOfCheckFieldInBits, bitsPerVerifier);
X		startOfCheckFieldInBits += bitsPerVerifier;
X	};
X	if (startOfCheckFieldInBits < WORD_SIZE_IN_BITS)
X		ErrAbort ("check field wouldn't fit");
X}
X
X/*  The following routine finishes an OTT (One Time Tree).  An
X *  OTT consists of several one-time signatures combined in a
X *  fixed-sized tree pattern by the use of one-way hash functions.
X *  (See, for example, "A Digital Signature Based on a Conventional
X *  Encryption Function" by Ralph C. Merkle, Crypto '87, page 369).
X *  This routine generates all of the needed one-time signatures, and
X *  computes the required hash value for the tree.  In addition, once
X *  the hash value for this OTT has been computed, the signature for
X *  the hash value, which must be generated using the appropriate
X *  one-time signature from the previous OTT, is also computed.
X */
Xvoid 
XFinishNewOTT (
X	top,
X	securitySize,
X	parameterSize,
X	hashMethod,
X	noOfCounts,
X	noOfBitsPerVerifier,
X	OTTsize,
X	authPathValues,
X	OTTparameterTop,
X	countVerifiers,
X	secretKey,
X	secretKeySize
X)
X	int     top;
X	int     securitySize;
X	int     parameterSize;
X	int     hashMethod;
X	int     noOfCounts;
X	int     noOfBitsPerVerifier;
X	int	OTTsize;
X	word32 authPathValues
X		[MAX_STACK_DEPTH]
X		[2 * MAX_OTT_SIZE]
X		[MAX_SECURITY_SIZE];
X	word32 OTTparameterTop[MAX_PARAMETER_SIZE];
X	word32 countVerifiers
X		[MAX_STACK_DEPTH]
X		[MAX_NO_OF_COUNTS]
X		[MAX_SECURITY_SIZE];
X	word32 secretKey[SECRET_KEY_SIZE];
X	int     secretKeySize;
X{	word32 i, j;
X	word32 parameter[MAX_PARAMETER_SIZE];
X	word32 dummyValueToSign[MAX_SECURITY_SIZE];
X	word32 throwAwayHashResult[MAX_SECURITY_SIZE];
X	word32 xyVector[MAX_NO_OF_COUNTS * MAX_SECURITY_SIZE];
X
X	for (i = 0; i < MAX_SECURITY_SIZE; i++)
X		dummyValueToSign[i] = 0;
X
X	/*
X	 * loop through for each one-time signature in the OTT and compute
X	 * its authentication value
X	 */
X	for (i = OTTsize; i < 2 * OTTsize; i++) {
X		Copy (parameter, OTTparameterTop, parameterSize);
X		UpPath (parameter, parameterSize, i);
X		UpLeft (parameter, parameterSize);
X		/* generate the secret X values with which we sign things  */
X		GenerateSecretXValues (xyVector, noOfCounts,
X			securitySize,
X			parameter, parameterSize,
X			secretKey, secretKeySize,
X			hashMethod);
X#if DEBUG
X		printf ("\ngenerating authPath value\n");
X		PrintIt ("path=", &i, 1);
X		PrintIt ("secretKey=", secretKey, secretKeySize);
X		PrintIt ("xyVector[last]=",
X		     &xyVector[noOfCounts * securitySize - 1], 1);
X		PrintIt ("parameter=", parameter, parameterSize);
X#endif
X		OneTimeSignCheck (dummyValueToSign, securitySize,
X				  parameter, parameterSize, COMPUTE_OTT_HASH,
X				  noOfCounts, noOfBitsPerVerifier,
X				  xyVector, authPathValues[top][i], hashMethod);
X
X#if DEBUG
X		printf ("\done generating authPath value\n");
X		PrintIt ("xyVector[last]=",
X		     &xyVector[noOfCounts * securitySize - 1], 1);
X		PrintIt ("parameter=", parameter, parameterSize);
X		PrintIt ("authPathValues[..]=",
X		       authPathValues[top][i], securitySize);
X#endif
X	};
X
X	for (i = OTTsize - 1; i > 0; i--) {
X		Copy (parameter, OTTparameterTop, parameterSize);
X		UpPath (parameter, parameterSize, i);
X#if DEBUG
X		printf ("\ngenerating non-leaves in authPathValues\n");
X		PrintIt ("path=", &i, 1);
X		PrintIt ("parameter=", parameter, parameterSize);
X		PrintIt ("authPathValues[top][2*path]=",
X		   authPathValues[top][2 * i], securitySize);
X		PrintIt ("authPathValues[top][2*path+1]=",
X			 authPathValues[top][2 * i + 1],
X			 securitySize);
X#endif
X		HashThreeItems (
X			authPathValues[top][i], securitySize,
X			authPathValues[top][2 * i], securitySize,
X			authPathValues[top][2 * i + 1], securitySize,
X			parameter, parameterSize,
X			hashMethod);
X
X#if DEBUG
X		printf ("\just-computed parent is:\n");
X		PrintIt ("authPathValues[top][path]=",
X		       authPathValues[top][i], securitySize);
X#endif
X	};
X
X	if (top > 0) {
X		/*
X		 * gotta add the signature from the previous OTT to this
X		 * OTT
X		 */
X		Copy (parameter, OTTparameterTop, parameterSize);
X		DownLeft (parameter, parameterSize);
X		UpLeft (parameter, parameterSize);
X		/* generate the secret X values with which we sign things  */
X		GenerateSecretXValues (xyVector, noOfCounts,
X				securitySize,
X				parameter, parameterSize,
X				secretKey, secretKeySize,
X				hashMethod);
X
X		OneTimeSignCheck (authPathValues[top][1],
X				securitySize,
X				parameter, parameterSize, SIGN,
X				noOfCounts, noOfBitsPerVerifier,
X				xyVector, throwAwayHashResult,
X				hashMethod);
X
X		for (i = 0; i < noOfCounts; i++)
X			for (j = 0; j < securitySize; j++)
X				countVerifiers[top][i][j] =
X					xyVector[i * securitySize + j];
X	};
X
X}
X
X/*
X * Write out the "aux Info" file in binary.  Convert the internal
X * information describing the signing "state" into a suitable binary
X * output format.  Note that the information in the auxilliary file
X * is not security sensitive, need not be kept secret, and can even
X * be modified.  If the information is modified, generated signatures
X * will be invalid (which will be rapidly detected) but security of
X * valid signatures will not be compromised.  Note that in principle
X * the incorrectly generated signatures could be repaired by determining
X * the correct authentication paths to use.
X */
Xvoid 
XWriteBinaryAuxInfo(top, securitySize, noOfCounts, OTTsize, authPathValues,
X	countVerifiers, toggle)
X	int     top;
X	int	securitySize;
X	int	noOfCounts;
X	int	OTTsize;
X	word32	authPathValues
X		[MAX_STACK_DEPTH]
X		[2 * MAX_OTT_SIZE]
X		[MAX_SECURITY_SIZE];
X	word32	countVerifiers
X		[MAX_STACK_DEPTH]
X		[MAX_NO_OF_COUNTS]
X		[MAX_SECURITY_SIZE];
X	int	toggle;
X{	FILE   *auxInfoFile;
X	int	writeReturnCode;
X	word32	temp[MAX_STACK_DEPTH*MAX_SECURITY_SIZE*2*MAX_OTT_SIZE];
X	int	i,j,k,loc;
X
X	if (2*MAX_OTT_SIZE < MAX_NO_OF_COUNTS)
X		ErrAbort("2*MAX_OTT_SIZE < MAX_NO_OF_COUNTS");
X	RangeCheck (top, 0, MAX_STACK_DEPTH - 1, "top");
X	auxInfoFile = fopen (AuxInfoFile(toggle), "wb");
X	if (auxInfoFile == NULL)
X		ErrAbort ("Can't open aux info file for write");
X	loc = 0;
X	for(i=1; i<=top; i++)
X	for(j=0; j<noOfCounts; j++)
X	for(k=0; k<securitySize; k++)
X		temp[loc++] = countVerifiers[i][j][k];
X	writeReturnCode = fwrite((char*)temp, 1,
X		top*noOfCounts*securitySize*sizeof(word32), auxInfoFile);
X	if (writeReturnCode !=
X		top*noOfCounts*securitySize*sizeof(word32)) {
X		fprintf(stderr,
X			"Can't write verifiers to %s\n", AuxInfoFile(toggle));
X		exit(1);
X	};
X	loc = 0;
X	for(i=0; i<=top; i++)
X	for(j=0; j<2*OTTsize; j++)
X	for(k=0; k<securitySize; k++)
X		temp[loc++] = authPathValues[i][j][k];
X	writeReturnCode = fwrite((char*)temp, 1,
X		(top+1)*2*OTTsize*securitySize*sizeof(word32), auxInfoFile);
X	if (writeReturnCode !=
X		(top+1)*2*OTTsize*securitySize*sizeof(word32)) {
X		fprintf(stderr,
X			"Can't write authPathValues to %s\n",
X				AuxInfoFile(toggle));
X		exit(1);
X	};
X	FileSyncAndClose(auxInfoFile, AuxInfoFile(toggle));
X}
X
X/*
X * Write out the signature buffer into the signature file.
X */
Xvoid 
XWriteSignatureBuffer (sigFile, sigBuffer)
X	FILE    *sigFile;
X	struct	SIG_BUF *sigBuffer;
X{	int     printCode;
X	char    charSignature[MAX_SIGNATURE_SIZE * 4];
X
X	/* write it!  */
X	ConvertLongToChar (sigBuffer->signature, charSignature,
X			   sigBuffer->locInSignature);
X	printCode = fwrite (charSignature, 4, sigBuffer->locInSignature,
X			    sigFile);
X	if (printCode != sigBuffer->locInSignature)
X		ErrAbort ("can't write auth path to *.sig");
X}
X
X/*
X * The following routine simply generates some more-or-less random bits and
X * puts them into "randomOutput".
X * 
X * Notice that this routine is adequate ONLY IF "machineKey" IS NOT GOING TO
X * BE KEPT SECRET.  If "machineKey" is going to be kept secret, then a more
X * random method of generating random numbers is required here.
X * 
X * Whether or not to keep "machineKey" secret is a system design issue not
X * addressed here.  It will often be desirable to keep it secret.
X *
X * Many implementors will well wish to use a better "random number" generator
X * than hashing the time....
X */
Xvoid 
XAssignRandom (randomOutput, sizeOfRandomOutputInWords,
X	      moreBits, sizeOfMoreBitsInWords)
X	word32 randomOutput[];
X	int     sizeOfRandomOutputInWords;
X	word32 moreBits[];
X	int     sizeOfMoreBitsInWords;
X{	word32 unSignedTime;
X
X	if (sizeOfRandomOutputInWords > 8)
X		ErrAbort ("can't generate enough random bits");
X	if (sizeOfRandomOutputInWords >
X			(sizeOfMoreBitsInWords + SECRET_KEY_SIZE))
X		ErrAbort ("too few input bits to generate random bits");
X	unSignedTime = GetTime32();
X	/*
X	 * hash together the time and whatever extra bits were passed in to
X	 * us
X	 */
X	HashTwoItems (randomOutput, sizeOfRandomOutputInWords,
X		      moreBits, sizeOfMoreBitsInWords,
X		      &unSignedTime, 1, 4);
X	/* randomOutput should now be reasonably random.  */
X}
X
X/*
X * Push an OTT (One Time Tree) onto the stack of One Time Trees.
X * Mostly, this is a housekeeping routine that pushes the stack,
X * initializes one or two critical variables in the OTT, and then
X * calles "FinishNewOTT".
X */
Xvoid 
XPushOTT (
X	topPtr,
X	securitySize,
X	parameterSize,
X	hashMethod,
X	noOfCounts,
X	noOfBitsPerVerifier,
X	path,
X	authPathValues,
X	OTTparameterTop,
X	countVerifiers,
X	secretKey,
X	secretKeySize,
X	OTTsize
X)
X	int    *topPtr;
X	int     securitySize;
X	int     parameterSize;
X	int     hashMethod;
X	int     noOfCounts;
X	int     noOfBitsPerVerifier;
X	word32 path[MAX_STACK_DEPTH];
X	word32 authPathValues
X		[MAX_STACK_DEPTH]
X		[2 * MAX_OTT_SIZE]
X		[MAX_SECURITY_SIZE];
X	word32 OTTparameterTop[MAX_PARAMETER_SIZE];
X	word32 countVerifiers
X		[MAX_STACK_DEPTH]
X		[MAX_NO_OF_COUNTS]
X		[MAX_SECURITY_SIZE];
X	word32 secretKey[SECRET_KEY_SIZE];
X	int     secretKeySize;
X	int	OTTsize;
X{	UpPath (OTTparameterTop, parameterSize, path[*topPtr]);
X	UpRight (OTTparameterTop, parameterSize);
X	(*topPtr)++;
X	if ((*topPtr) >= MAX_STACK_DEPTH)
X		ErrAbort ("stack overflow");
X
X	FinishNewOTT (*topPtr, securitySize,
X		parameterSize, hashMethod,
X		noOfCounts, noOfBitsPerVerifier,
X		OTTsize, authPathValues,
X		OTTparameterTop, countVerifiers,
X		secretKey, secretKeySize);
X}
X
X
X/*
X * The following routine determines how much (if any) the stack of OTTs
X * should be allowed to grow.
X * 
X * The following method was chosen so that an infinite number of messages can be
X * signed while the depth (size) of the signature grows logarithmically. It
X * would also be possible to have this routine return a simple fixed constant
X * (like 4), in which case all signatures would have the same size (a stack
X * depth of 4) but the number of signatures would be fixed and finite.
X * 
X * This method of generating signatures also has the useful property that an OTT
X * can be generated once, used for a while, and then forgotten.  Other
X * methods of generating signatures (other patterns of signatures within the
X * tree) result in the need to periodically re-create OTTs.  While no great
X * burden, it seemed easier to avoid this situation.
X *
X * A small modification was made -- MIN_DEPTH is the minimum value that
X * this function will return.  This is useful when it is known that some
X * fixed number of messages will be signed, so there is no point in generating
X * very small signatures initially (with top = 0, say) when this
X * will simply force longer signatures later.
X * In other words, the tree of OTTs will
X * always have at least a certain depth (from the root OTT to the leaf OTT).
X */
Xint 
XComputeNewStackTop (top, path)
X	int     top;
X	word32 path[MAX_STACK_DEPTH];
X{	int     i;
X	int     newTop;
X	int     bitsInPath;
X	word32 signatureNumber;
X	word32 signaturesAllowed;
X	int     depthToAdd;
X
X
X	/*
X	 * fancy computation basically determines how much stack depth to add
X	 * for the level we're looking at in the stack.
X	 * 
X	 * Example:  if the number of one-time signatures allowed per OTT is
X	 * always 32, then we want the following pattern for the first level:
X	 */
X	/**
X	32+0  <= path[0] < 32+16:	desired top: 0
X	32+16 <= path[0] < 32+24:	desired top: 1
X	32+24 <= path[0] < 32+28:	desired top: 2
X	32+28 <= path[0] < 32+30:	desired top: 3
X	32+30 <= path[0] < 32+31:	desired top: 4
X	32+31  = path[0]		desired top: look at next level
X	*/
X	/*
X	 * Note:  "path[0]" enumerates the leaves of this OTT (the one time
X	 * signatures) by encoding the first path as 32, the second path as
X	 * 33, etc. etc.  The last path is numbered 63.  There are a total of
X	 * 32 paths: numbered 32 to 63.
X	 * 
X	 */
X
X	newTop = 0;
X	for (i = 0; i <= top; i++) {
X
X		/* Figure out where the top bit is */
X		bitsInPath = SizeInBits (path[i]) - 1;
X
X		/* Make a mask of just the top bit  */
X		signaturesAllowed = (word32) 1 << bitsInPath;
X
X		/* Now knock off the top bit  */
X		signatureNumber = path[i] ^ signaturesAllowed;
X
X		if (signatureNumber >= signaturesAllowed)
X			ErrAbort ("logic error: sigNum >= sigsAllowed");
X
X		/* And compute how much more depth to add to the stack  */
X		depthToAdd = bitsInPath -
X			SizeInBits (signaturesAllowed - signatureNumber - 1);
X
X		if (depthToAdd < 0)
X			ErrAbort ("logic error: depthToAdd < 0");
X
X		newTop += depthToAdd;
X
X		/*
X		 * If we're using the very last signature at this depth, we
X		 * need to look at the next depth to compute new top.
X		 * Otherwise, we know the value of newTop right now and
X		 * should return.
X		 */
X		if (signaturesAllowed > signatureNumber + 1) {
X			/*  force depth to MIN_DEPTH no matter what */
X			if (newTop < MIN_DEPTH) newTop = MIN_DEPTH;
X			return (newTop);
X		}
X	};
X	/*  force depth to MIN_DEPTH no matter what */
X	if (newTop < MIN_DEPTH) newTop = MIN_DEPTH;
X	return (newTop);
X}
X
X
X
X/*
X * The following routine reads and hashes the input (taken from
X * "inputFile") and generates a valid signature for that hash.
X * The valid signature is written into the file: "sigFile".
X * The provided userKeyString is a secret key provided by the
X * user.  This user-provided secret key is combined with the
X * "machineKey" (which might or might not be secret, depending
X * on the desires of the particular user/site) to generate the
X * secretKey which is actually used to sign messages.
X * Much of the code is taken up
X * with the trivia of error checking, command-line parameter checking,
X * self-tests, and the like.
X * 
X */
X
Xvoid 
XSign (userKeyString, message, inputFile, sigFile)
X	char	*userKeyString;
X	char	message[MAX_MESSAGE_SIZE_IN_BYTES];
X	FILE	*inputFile;
X	FILE	*sigFile;
X{	int     top;
X	int     newStackTop;
X	int     i;
X	word32	parameter[MAX_PARAMETER_SIZE];
X	word32	throwAwayHashResult[MAX_SECURITY_SIZE];
X	word32	temp;
X	int     updateAuxInfo;
X	int     hashMethod;
X	int     securitySize;
X	int     hashValueSize;
X	word32	hashValue[MAX_HASH_VALUE_SIZE];
X	char	charUserKey[USER_KEY_SIZE_IN_BYTES];
X	word32	userKey[USER_KEY_SIZE];
X	word32	secretKey[SECRET_KEY_SIZE];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	hashedUserKey[HASHED_USER_KEY_SIZE];
X	word32	machineKey[MACHINE_KEY_SIZE];
X	word32	authPathValues
X	        [MAX_STACK_DEPTH]
X	        [2 * MAX_OTT_SIZE]
X	        [MAX_SECURITY_SIZE];
X	word32	countVerifiers
X	        [MAX_STACK_DEPTH]
X	        [MAX_NO_OF_COUNTS]
X	        [MAX_SECURITY_SIZE];
X	word32	path[MAX_STACK_DEPTH];
X	int     noOfCounts;
X	int     noOfBitsPerVerifier;
X	word32	rootParameter[MAX_PARAMETER_SIZE];
X	word32	checkValue[MAX_SECURITY_SIZE];
X	word32	root[MAX_SECURITY_SIZE];
X	word32	xyVector[MAX_NO_OF_COUNTS * MAX_SECURITY_SIZE];
X	int     parameterSize;
X	struct	SIG_BUF sigBuffer[1];
X	word32	tempHSC[HASHED_USER_KEY_SIZE];
X	word32	dateTime32;
X	word32	wordMessage[MAX_MESSAGE_SIZE];
X	int	messageSize;
X	int	messageSizeInBytes;
X	word32	wordsToHash;
X	word32	*hashPtr;
X	word32	binaryDataFieldSize;
X	int	startOfBinaryData;
X	int	endOfBinaryData;
X	int	chunkSize;
X	char	file1Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	char	file2Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	FILE	*file1;
X	FILE	*file2;
X	int	toggle;
X	int	OTTsize;
X#if SHOW_TIMES
X	word32	startTime, stopTime;
X	int	signRepeatIndex;
X	double	signTime;
X	int	rememberedTop;
X#endif
X
X	/* self-test, to make sure everything is okay.  */
X	DoSelfTest (SELF_TEST);
X	strncpy(charUserKey, userKeyString, USER_KEY_SIZE_IN_BYTES);
X	ConvertBytes (charUserKey, userKey, USER_KEY_SIZE_IN_BYTES);
X	NameStableStorage(file1Name, file2Name);
X	OpenAndLockTwoFiles(&file1, file1Name, &file2, file2Name);
X	ReadStableStorage (file1, file2, machineKey, publicKey,
X		hashedUserKey, path, &top, &toggle, &OTTsize);
X	UnPackHeader (publicKey[0], &hashMethod,
X			&securitySize, &parameterSize,
X			&noOfBitsPerVerifier, &hashValueSize, &noOfCounts);
X	HashTwoItems(tempHSC, HASHED_USER_KEY_SIZE,
X		userKey, USER_KEY_SIZE,
X		userKey, USER_KEY_SIZE, hashMethod);
X	for (i=0; i<20; i++) HashTwoItems(
X				tempHSC, HASHED_USER_KEY_SIZE,
X				tempHSC, HASHED_USER_KEY_SIZE,
X				tempHSC, HASHED_USER_KEY_SIZE,
X				hashMethod);
X	for (i=0; i<HASHED_USER_KEY_SIZE; i++)
X		if (tempHSC[i] != hashedUserKey[i])
X			ErrAbort("Incorrect user key entered.");
X	Copy(root, &publicKey[1], securitySize);
X	Copy(rootParameter, &publicKey[1+securitySize], parameterSize);
X	/*
X	 * Hash the user-provided key (presumed to be secret) and the
X	 * machine-readable key (security is enhanced if the machine key is
X	 * also secret.  If the machine key is not secret, it still serves a
X	 * useful, though less important, function).
X	 * 
X	 * The result is the "secretKey", from which all other secret
X	 * information is generated in a deterministic manner.
X	 */
X
X#if DEBUG
X	PrintIt ("machine key is:",
X		 machineKey, MACHINE_KEY_SIZE);
X	PrintIt ("user key is:",
X		 userKey, USER_KEY_SIZE);
X#endif
X
X	HashTwoItems (secretKey, SECRET_KEY_SIZE,
X		      machineKey, MACHINE_KEY_SIZE,
X		      userKey, USER_KEY_SIZE,
X		      hashMethod);
X#if DEBUG
X	PrintIt ("Secret key for signing is:", secretKey, SECRET_KEY_SIZE);
X#endif
X	/* Generate the digital signature  */
X#if SHOW_TIMES
X	startTime = GetCpuTime();
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X#endif
X	ReadBinaryAuxInfo (top, securitySize, noOfCounts,
X		OTTsize, authPathValues,
X		countVerifiers, toggle);
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds reading binary state\n",
X		signTime);
X	startTime = GetCpuTime();
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X#endif
X
X	HashFile (inputFile, hashValue, hashValueSize, hashMethod);
X
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds hashing file\n",
X		signTime);
X	startTime = GetCpuTime();
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X#endif
X	/* get the root parameter  */
X	Copy (parameter, rootParameter, parameterSize);
X
X	/*  push the root parameter up the authentication path */
X	for (i=0; i <= top; i++) {
X		UpPath (parameter, parameterSize, path[i]);
X		UpRight (parameter, parameterSize);
X		};
X
X	/* spit out the head of the signature  */
X	EmptySignatureBuffer (sigBuffer);
X	PackHeader(&temp, hashMethod, securitySize,
X		parameterSize, noOfBitsPerVerifier);
X	PutInSignatureBuffer (&temp, 1, sigBuffer);
X	if (top >= 255)
X		ErrAbort ("Stack exceeds depth of 255");
X	temp = top + 1;
X	messageSizeInBytes = strlen(message)+1;
X	messageSize = (messageSizeInBytes+3)>>2;
X	binaryDataFieldSize = 1+hashValueSize+parameterSize;
X	wordsToHash = 2+binaryDataFieldSize+messageSize;
X	if ( (wordsToHash & 0xffff0000L) != 0)
X		ErrAbort("message + stuff over 64 kilobytes.");
X	temp |= (wordsToHash<<16);
X	temp |= (binaryDataFieldSize << 8);
X	PutInSignatureBuffer (&temp, 1, sigBuffer);
X
X	startOfBinaryData = sigBuffer->locInSignature;
X#if DEBUG
X	PrintIt ("\n initial parameter=", parameter, parameterSize);
X#endif
X	dateTime32 = GetTime32();
X	PutInSignatureBuffer (&dateTime32, 1, sigBuffer);
X	PutInSignatureBuffer (hashValue, hashValueSize, sigBuffer);
X	PutInSignatureBuffer (parameter, parameterSize, sigBuffer);
X/*
X * Additional binary fields of data can be added at this point by
X * inserting additional calls to "PutInSignatureBuffer".  The additional
X * fields will be ignored by the signature checking program.  To inform
X * the signature checking program of the size of the additional fields,
X * it is necessary to increase the size of "binaryDataFieldSize" by the
X * appropriate amount.  It is computed above, and its value is checked
X * in the following two statements.
X */
X	endOfBinaryData = sigBuffer->locInSignature;
X	if ( (endOfBinaryData-startOfBinaryData) != binaryDataFieldSize)
X		ErrAbort("error while generating size of binary data field");
X	ConvertBytes(message, wordMessage, messageSizeInBytes);
X	PutInSignatureBuffer (wordMessage, messageSize, sigBuffer);
X	if (wordMessage[messageSize-1]&0xffL != 0)
X		ErrAbort("wordMessage is not null terminated");
X	hashPtr = sigBuffer->signature;
X	for (i=0; i<hashValueSize; i++) hashValue[i] = 0;
X	i = wordsToHash;
X	chunkSize = INPUT_BLOCK_SIZE-hashValueSize;
X	while (i >= chunkSize) {
X		HashTwoItems(hashValue, hashValueSize,
X			hashValue, hashValueSize,
X			hashPtr, chunkSize, hashMethod);
X		hashPtr += chunkSize;
X		i -= chunkSize;
X	};
X	if (i>0)  HashTwoItems(hashValue, hashValueSize,
X			hashValue, hashValueSize,
X			hashPtr, i,hashMethod);
X	HashTwoItems(hashValue, hashValueSize,
X		hashValue, hashValueSize,
X		&wordsToHash, 1, hashMethod);
X	/*
X	 * hash the double-sized value produced by the strong hash function
X	 * into the smaller value that is actually signed.
X	 */
X#if DEBUG
X	printf ("SIGNING\n");
X	PrintIt ("hashValue=", hashValue, hashValueSize);
X	PrintIt ("parameter=", parameter, parameterSize);
X#endif
X	HashTwoItems (checkValue, securitySize,
X		      hashValue, hashValueSize,
X		      parameter, parameterSize,
X		      hashMethod);
X	DownLeft (parameter, parameterSize);
X	UpLeft (parameter, parameterSize);
X	/* generate the secret X values with which we sign things  */
X	GenerateSecretXValues (xyVector, noOfCounts, securitySize,
X			       parameter, parameterSize,
X			       secretKey, SECRET_KEY_SIZE, hashMethod);
X
X#if DEBUG
X	printf ("\nAbout to generate one time signature\n");
X	PrintIt ("path=", &path[top], 1);
X	PrintIt ("secretKey=", secretKey, SECRET_KEY_SIZE);
X	PrintIt ("xyVector[last]=",
X		 &xyVector[noOfCounts * securitySize - 1], 1);
X	PrintIt ("checkValue=", checkValue, securitySize);
X	PrintIt ("parameter=", parameter, parameterSize);
X#endif
X
X	OneTimeSignCheck (checkValue, securitySize,
X			  parameter, parameterSize, SIGN,
X			  noOfCounts, noOfBitsPerVerifier,
X			  xyVector, throwAwayHashResult, hashMethod);
X
X#if DEBUG
X	printf ("\nfinished generating one time signature\n");
X	PrintIt ("xyVector[last]=",
X		 &xyVector[noOfCounts * securitySize - 1], 1);
X	PrintIt ("checkValue (discarded)=",
X		 throwAwayHashResult, securitySize);
X#endif
X	for (i = 0; i < noOfCounts; i++)
X		PutInSignatureBuffer (&xyVector[i * securitySize],
X				      securitySize, sigBuffer);
X	GenerateAuthenticationPath (top, securitySize,
X				    noOfCounts, path, countVerifiers,
X				    authPathValues, sigBuffer);
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds generating signature\n",
X		signTime);
X#endif
X	/*
X	 * make sure the aux info is updated in preparation for the next
X	 * signature
X	 */
X	updateAuxInfo = FALSE;
X	if (BumpPath (&path[top]) == PATHOVERFLOW) {
X		updateAuxInfo = TRUE;
X		/*
X		 * We've run out of signatures in the top OTT. Do Something!
X		 */
X		while (BumpPath (&path[top]) == PATHOVERFLOW) {
X			top--;
X			if (top < 0)
X				ErrAbort ("Logic Error: no signatures");
X		};
X	};
X#if SHOW_TIMES
X	startTime = GetCpuTime();
X	rememberedTop = top;
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X	top = rememberedTop;
X#endif
X	newStackTop = ComputeNewStackTop (top, path);
X	if (newStackTop != top)
X		updateAuxInfo = TRUE;
X#if DEBUG
X	printf ("\n new top= %d\n", newStackTop);
X#endif
X	/* get the root parameter  */
X	Copy (parameter, rootParameter, parameterSize);
X	/*  push the root parameter up the authentication path */
X	for (i=0; i < top; i++) {
X		UpPath (parameter, parameterSize, path[i]);
X		UpRight (parameter, parameterSize);
X		};
X	while (top < newStackTop) {
X		path[top+1] = OTTsize;
X		PushOTT (&top, securitySize, parameterSize, hashMethod,
X			   noOfCounts, noOfBitsPerVerifier,
X			   path, authPathValues,
X			   parameter, countVerifiers,
X			   secretKey, SECRET_KEY_SIZE, OTTsize);
X		};
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds setting up for next signature\n",
X		signTime);
X	startTime = GetCpuTime();
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X#endif
X	if (updateAuxInfo == TRUE) {
X		toggle ^= 1;
X		WriteBinaryAuxInfo(top, securitySize,
X			noOfCounts, OTTsize, authPathValues,
X			countVerifiers, toggle);
X	};
X	/*
X	 * DON'T WRITE OUT THE SIGNATURE UNTIL AFTER UPDATING STABLE
X	 * STORAGE!!
X	 */
X	WriteStableStorage (file1, file2, machineKey, publicKey,
X			hashedUserKey, path, top, toggle, OTTsize);
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds writing stable storage\n",
X		signTime);
X#endif
X/*  Hard to repeatedly close the file.... */
X	FileSyncAndClose(file1, file1Name);
X	FileSyncAndClose(file2, file2Name);
X#if SHOW_TIMES
X	startTime = GetCpuTime();
X	for(signRepeatIndex=0; signRepeatIndex<1000; signRepeatIndex++) {
X#endif
X	WriteSignatureBuffer (sigFile, sigBuffer);
X#if SHOW_TIMES
X 	};
X	stopTime = GetCpuTime();
X	signTime = stopTime-startTime;
X	signTime = signTime/1.0e6;
X	fprintf(stderr, "%9.3f milliseconds writing state and signature\n",
X		signTime);
X#endif
X};
X
X/* The following routine writes an entry to the public file.  It
X * is used during generation of the public key.  Note that the
X * "public file" is in fact a directory, and that the file names
X * in the directory are in fact derived from the public key
X * values, not from the user's name.  This is convenient for various
X * odd reasons that are idiosyncratic to this signature method.
X * Each public key gets its own file in the directory.  Note that
X * it is theoretically possible (but can be made arbitrarily
X * improbable) for two different public keys to have the same
X * file name in the public directory.  If this happens, it's just
X * tough.  You get an error message and are told to try again.
X * For those who find this offensive, the file name for the public
X * key could in fact encode the entire public key.  In this case,
X * a collsion in the directory would be as improbable as two
X * public keys being generated that were in fact identical.  This
X * probability can also be made as low as desired.
X */
Xvoid 
XWriteEntryToPublicFile (publicDirectoryName, name, publicKey,
X			secretKey, secretKeySize)
X	char   *publicDirectoryName;
X	char    name[];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32 secretKey[];
X	int secretKeySize;
X{	int     i;
X	FILE   *descriptor;
X	int     printReturnCode;
X	int	publicKeySize;
X	char	*publicFileName;
X
X	/* open the "public file" entry for writing */
X	publicFileName = MakePublicFileName(publicDirectoryName, publicKey);
X	if (FileExists(publicFileName) == 0)
X		ErrAbort("Highly improbable collision occured -- try again.");
X	descriptor = fopen (publicFileName, "w");
X	if (descriptor == NULL)
X		ErrAbort ("Could not write entry to public file");
X
X	printReturnCode = fprintf (descriptor, "#%s: %08lx",
X		name, publicKey[0]);
X	if (printReturnCode <= 0)
X		ErrAbort ("bad write to public file");
X
X	publicKeySize = ComputePublicKeySize(publicKey);
X	for (i = 1; i < publicKeySize; i++) {
X		printReturnCode = fprintf (descriptor,
X					   " %08lx", publicKey[i]);
X	if (printReturnCode <= 0)
X		ErrAbort ("bad public key write to public file");
X	};
X
X	printReturnCode = fprintf (descriptor, "\n");
X	if (printReturnCode <= 0)
X		ErrAbort ("bad string write to public file");
X	FileClose (descriptor, publicFileName);
X};
X
X/* The following routine is used to recover the auxilliary information
X * if it is damaged or lost.  The auxilliary information can be derived
X * from the information kept in stable storage.
X */
Xvoid
XRecoverAuxInfo(userKeyString)
X	char	*userKeyString;
X{	int	top;
X	int	newStackTop;
X	int	i;
X	int	hashMethod;
X	int	securitySize;
X	int	hashValueSize;
X	char	charUserKey[USER_KEY_SIZE_IN_BYTES];
X	word32	userKey[USER_KEY_SIZE];
X	word32	secretKey[SECRET_KEY_SIZE];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	hashedUserKey[HASHED_USER_KEY_SIZE];
X	word32	machineKey[MACHINE_KEY_SIZE];
X	word32	authPathValues
X	        [MAX_STACK_DEPTH]
X	        [2 * MAX_OTT_SIZE]
X	        [MAX_SECURITY_SIZE];
X	word32	countVerifiers
X	        [MAX_STACK_DEPTH]
X	        [MAX_NO_OF_COUNTS]
X	        [MAX_SECURITY_SIZE];
X	word32	path[MAX_STACK_DEPTH];
X	int     noOfCounts;
X	int     noOfBitsPerVerifier;
X	word32	rootParameter[MAX_PARAMETER_SIZE];
X	word32	root[MAX_SECURITY_SIZE];
X	int     parameterSize;
X	word32	tempHSC[HASHED_USER_KEY_SIZE];
X	char	file1Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	char	file2Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	FILE	*file1;
X	FILE	*file2;
X	int	toggle;
X	int	OTTsize;
X
X	strncpy(charUserKey, userKeyString, USER_KEY_SIZE_IN_BYTES);
X	ConvertBytes (charUserKey, userKey, USER_KEY_SIZE_IN_BYTES);
X	NameStableStorage(file1Name, file2Name);
X	OpenAndLockTwoFiles(&file1, file1Name, &file2, file2Name);
X	ReadStableStorage (file1, file2, machineKey, publicKey,
X		hashedUserKey, path, &newStackTop, &toggle, &OTTsize);
X	UnPackHeader (publicKey[0], &hashMethod,
X			&securitySize, &parameterSize,
X			&noOfBitsPerVerifier, &hashValueSize, &noOfCounts);
X	HashTwoItems(tempHSC, HASHED_USER_KEY_SIZE,
X		userKey, USER_KEY_SIZE,
X		userKey, USER_KEY_SIZE, hashMethod);
X	for (i=0; i<20; i++) HashTwoItems(
X				tempHSC, HASHED_USER_KEY_SIZE,
X				tempHSC, HASHED_USER_KEY_SIZE,
X				tempHSC, HASHED_USER_KEY_SIZE,
X				hashMethod);
X	for (i=0; i<HASHED_USER_KEY_SIZE; i++)
X		if (tempHSC[i] != hashedUserKey[i])
X			ErrAbort("Incorrect user key entered.");
X	Copy(root, &publicKey[1], securitySize);
X	Copy(rootParameter, &publicKey[1+securitySize], parameterSize);
X	/*
X	 * Hash the user-provided key (presumed to be secret) and the
X	 * machine-readable key (security is enhanced if the machine key is
X	 * also secret.  If the machine key is not secret, it still serves a
X	 * useful, though less important, function).
X	 * 
X	 * The result is the "secretKey", from which all other secret
X	 * information is generated in a deterministic manner.
X	 */
X
X	HashTwoItems (secretKey, SECRET_KEY_SIZE,
X		      machineKey, MACHINE_KEY_SIZE,
X		      userKey, USER_KEY_SIZE,
X		      hashMethod);
X	/* initialize the top (i.e. 0th) OTT  */
X	top = 0;
X	FinishNewOTT (top, securitySize, parameterSize, hashMethod,
X			noOfCounts, noOfBitsPerVerifier, OTTsize,
X			authPathValues, rootParameter, countVerifiers,
X			secretKey, SECRET_KEY_SIZE);
X	for (i=0; i<securitySize; i++)
X		if(root[i] != authPathValues[0][1][i])
X			ErrAbort("Recovery failed");
X	while (top < newStackTop) {
X		PushOTT (&top, securitySize, parameterSize, hashMethod,
X			noOfCounts, noOfBitsPerVerifier,
X			path, authPathValues,
X			rootParameter, countVerifiers,
X			secretKey, SECRET_KEY_SIZE, OTTsize);
X		};
X	WriteBinaryAuxInfo(top, securitySize,
X		noOfCounts, OTTsize, authPathValues, countVerifiers, toggle);
X}
X
X/*
X * The following routine creates new signing key/checking key pair and writes
X * out the new initial aux info and the new public entry.
X */
Xvoid 
XCreateSignCheckPair (userKeyString, userName, publicDirName, hashMethod,
X	securitySize, parameterSize, noOfBitsPerVerifier, OTTsize)
X	char	*userKeyString;
X	char	*userName;
X	char	*publicDirName;
X	int	hashMethod;
X	int	securitySize;
X	int	parameterSize;
X	int	noOfBitsPerVerifier;
X{	int     i;
X	char    charUserKey[USER_KEY_SIZE_IN_BYTES];
X	word32	userKey[USER_KEY_SIZE];
X	word32	secretKey[SECRET_KEY_SIZE];
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	word32	hashedUserKey[HASHED_USER_KEY_SIZE];
X
X	word32	machineKey[MACHINE_KEY_SIZE];
X	int     top;
X	int	newStackTop;
X	word32	authPathValues
X	        [MAX_STACK_DEPTH]
X	        [2 * MAX_OTT_SIZE]
X	        [MAX_SECURITY_SIZE];
X	word32	countVerifiers
X	        [MAX_STACK_DEPTH]
X	        [MAX_NO_OF_COUNTS]
X	        [MAX_SECURITY_SIZE];
X	word32	OTTparameter[MAX_STACK_DEPTH][MAX_PARAMETER_SIZE];
X	word32	path[MAX_STACK_DEPTH];
X	int     noOfCounts;
X	word32	rootParameter[MAX_PARAMETER_SIZE];
X	word32	root[MAX_SECURITY_SIZE];
X	word32	parameter[MAX_PARAMETER_SIZE];
X	FILE	*file1;
X	FILE	*file2;
X	char	file1Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	char	file2Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X
X	RangeCheck(securitySize, 2, MAX_SECURITY_SIZE, "Security size");
X	RangeCheck(parameterSize, 2, MAX_PARAMETER_SIZE, "Parameter size");
X	RangeCheck(noOfBitsPerVerifier, 1, MAX_BITS_PER_VERIFIER,
X		"no of bits per verifier");
X	RangeCheck(OTTsize, 4, MAX_OTT_SIZE, "OTT size");
X	if ( ((OTTsize-1) & OTTsize) != 0) {
X		fprintf(stderr, "OTT size is %d, not a power of 2\n",
X			OTTsize);
X		ErrAbort("");
X	};
X	strncpy(charUserKey, userKeyString, USER_KEY_SIZE_IN_BYTES);
X	ConvertBytes (charUserKey, userKey, USER_KEY_SIZE_IN_BYTES);
X	top = 0;
X	noOfCounts = ComputeNumberOfCounts (
X		      securitySize, WORD_SIZE_IN_BITS, noOfBitsPerVerifier);
X	/* generate the machine key  */
X	AssignRandom (machineKey, MACHINE_KEY_SIZE, userKey, USER_KEY_SIZE);
X#if DEBUG
X	PrintIt ("machine key is:",
X		 machineKey, MACHINE_KEY_SIZE);
X	PrintIt ("user key is:",
X		 userKey, USER_KEY_SIZE);
X#endif
X
X	/* and now we can generate the secret key */
X	HashTwoItems (secretKey, SECRET_KEY_SIZE,
X		      machineKey, MACHINE_KEY_SIZE,
X		      userKey, USER_KEY_SIZE,
X		      hashMethod);
X#if DEBUG
X	PrintIt ("Secret key created is:", secretKey, SECRET_KEY_SIZE);
X#endif
X	/* Generate the random root parameter  */
X	AssignRandom (rootParameter, parameterSize, secretKey, SECRET_KEY_SIZE);
X	/*
X	 * The root parameter is now modified to have certain desirable
X	 * properties.  The purpose of these modifications is to simplify the
X	 * analysis of parameter-parameter collisions (i.e., to make it
X	 * simpler to figure out when two parameters are likely to collide --
X	 * which can result in a modest reduction in security).  In addition,
X	 * when the following modifications are made to the parameter, a
X	 * large class of collisions become impossible.  In particular,
X	 * collisions between two parameters used with the same secret
X	 * signing key are impossible if the number of signed messages is
X	 * less than 2**60 or so.
X	 * 
X	 * The fact that two parameters are guaranteed to be different for two
X	 * different locations in the same tree is used to generate different
X	 * secret information for different locations in the tree.  Should
X	 * the parameters at two different locations in the tree collide, the
X	 * result would be a major loss of security.  This is because the
X	 * secret signing information is generated deterministically from (a)
X	 * the secret key and (b) the parameter value at that point in the
X	 * tree.  Thus, should two parameters be identical, the corresponding
X	 * secret information for two one-time signatures would be identical,
X	 * which is very bad.
X	 * 
X	 */
X
X	rootParameter[parameterSize - 1] |= 0x1fL;	/* Bottom 5 bits are:
X							 * 11111  */
X	rootParameter[parameterSize - 1] ^= 0xfL;	/* Bottom 5 bits are:
X							 * 10000  */
X	for (i = WORD_SIZE_IN_BITS * parameterSize - 5; i >= 0; i--)
X		if (FetchBits (rootParameter, parameterSize, i, 4) == 0)
X			SetBit (rootParameter, i);
X
X	for (i = WORD_SIZE_IN_BITS * parameterSize - 5; i >= 0; i--)
X		if (FetchBits (rootParameter, parameterSize, i, 4) == 0)
X			ErrAbort ("Internal logic error");
X	/* End of diddling the root parameter  */
X
X	/* initialize the top (i.e. 0th) OTT  */
X	Copy (OTTparameter[top], rootParameter, parameterSize);
X	path[top] = OTTsize;
X	FinishNewOTT (top, securitySize, parameterSize, hashMethod,
X			noOfCounts, noOfBitsPerVerifier, OTTsize,
X			authPathValues, OTTparameter[top], countVerifiers,
X			secretKey, SECRET_KEY_SIZE);
X	Copy (root, authPathValues[top][1], securitySize);
X	newStackTop = ComputeNewStackTop (top, path);
X	Copy (parameter, rootParameter, parameterSize);
X	while (top < newStackTop) {
X		path[top+1] = OTTsize;
X		PushOTT (&top, securitySize, parameterSize, hashMethod,
X			noOfCounts, noOfBitsPerVerifier,
X			path, authPathValues,
X			parameter, countVerifiers,
X			secretKey, SECRET_KEY_SIZE, OTTsize);
X		};
X	/*  generate public key */
X	PackHeader(publicKey, hashMethod, securitySize,
X		parameterSize, noOfBitsPerVerifier);
X	Copy(&publicKey[1], root, securitySize);
X	Copy(&publicKey[1+securitySize], rootParameter, parameterSize);
X	HashTwoItems(hashedUserKey, HASHED_USER_KEY_SIZE,
X		userKey, USER_KEY_SIZE,
X		userKey, USER_KEY_SIZE, hashMethod);
X	for (i=0; i<20; i++) HashTwoItems(
X				hashedUserKey, HASHED_USER_KEY_SIZE,
X				hashedUserKey, HASHED_USER_KEY_SIZE,
X				hashedUserKey, HASHED_USER_KEY_SIZE,
X				hashMethod);
X	NameStableStorage(file1Name, file2Name);
X	file1 = OpenIfEmpty(file1Name);
X	file2 = OpenIfEmpty(file2Name);
X	WriteStableStorage (file1, file2, machineKey,
X		publicKey, hashedUserKey, path, top, 0, OTTsize);
X	FileSyncAndClose(file1, file1Name);
X	FileSyncAndClose(file2, file2Name);
X	WriteBinaryAuxInfo(top, securitySize,
X		noOfCounts, OTTsize, authPathValues, countVerifiers, 0);
X	WriteEntryToPublicFile (publicDirName, userName,
X				publicKey, secretKey, SECRET_KEY_SIZE);
X
X}
X
X/*
X * The following routine writes 0's over the old signing key, if
X * the file exists.
X */
Xvoid
XDestroyOldKey()
X{	char	file1Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	char	file2Name[MAX_FILE_NAME_SIZE_IN_BYTES];
X	FILE	*file1;
X	FILE	*file2;
X	char	nothing[WIPE_IT];
X	int	i;
X	int	fileSize;
X
X	for(i=0; i<WIPE_IT; i++) nothing[i] = (char) 0;
X	NameStableStorage(file1Name, file2Name);
X	if (FileExists(file1Name) != 0)
X		fprintf(stderr, "File \"%s\" does not exist\n", file1Name);
X	else {
X		file1 = fopen(file1Name, "r+");
X		if (file1 == (FILE *) NULL)
X			fprintf(stderr, "Can't open \"%s\" for modify\n",
X				file1Name);
X		else  {
X			fseek(file1, 0L, 2);
X			fileSize = ftell(file1);
X			if (fileSize < 100) fileSize = 100;
X			if (fileSize > WIPE_IT) fileSize = WIPE_IT;
X			fseek(file1, 0L, 0);
X			if (fwrite(nothing, 1, fileSize, file1) != fileSize)
X				fprintf(stderr, "Can't write to \"%s\"\n",
X					file1Name);
X			FileSyncAndClose(file1, file1Name);
X		};
X	};
X	if (FileExists(file2Name) != 0)
X		fprintf(stderr, "File \"%s\" does not exist\n", file2Name);
X	else {
X		file2 = fopen(file2Name, "r+");
X		if (file2 == (FILE *) NULL)
X			fprintf(stderr, "Can't open \"%s\" for modify\n",
X				file2Name);
X		else {
X			fseek(file2, 0L, 2);
X			fileSize = ftell(file2);
X			if (fileSize < 100) fileSize = 100;
X			if (fileSize > WIPE_IT) fileSize = WIPE_IT;
X			fseek(file2, 0L, 0);
X			if (fwrite(nothing, 1, fileSize, file2) != fileSize)
X				fprintf(stderr, "Can't write to \"%s\"\n",
X					file2Name);
X			FileSyncAndClose(file2, file2Name);
X		};
X	};
X}
X
X/*
X * given integer hashMethod, determine the proper string name
X * (printable name) for that hash method.
X */
Xchar *
XNameForHashMethod(hashMethod)
X	int	hashMethod;
X{
X	switch (hashMethod) {
X	case SNEFRU4_METHOD:	return("Snefru4");
X	case MD4_METHOD:	return("MD4");
X	default:		return("Unknown");
X
X	};
X}
X
X
X/*
X * Given a string, s, select the proper integer value for the
X * hash method specified by the string.
X * Allowed hash methods are:  SNEFRU4_METHOD and MD4_METHOD.
X * Other hashing methods can be added in the future as warranted.
X * Please contact Xerox before selecting a constant for
X * a new method -- the constant value specifying a given
X * method should be unique.  Values less than 100 are reserved,
X * and should not be used except by Xerox.
X */
Xint
XSelectHashMethod(s)
X	char	*s;
X{	if (strcmp(s,"md4"		)==0)	return(MD4_METHOD);
Xelse if (strcmp(s,"MD4"		)==0)	return(MD4_METHOD);
Xelse if (strcmp(s,"snefru4"	)==0)	return(SNEFRU4_METHOD);
Xelse if (strcmp(s,"snefru"	)==0)	return(SNEFRU4_METHOD);
Xelse if (strcmp(s,"SNEFRU4"	)==0)	return(SNEFRU4_METHOD);
Xelse if (strcmp(s,"SNEFRU"	)==0)	return(SNEFRU4_METHOD);
Xelse ErrAbort("Method must be md4 or snefru[4]");
Xreturn(-1);
X};
X
X/*
X * The main program reads in a command line, interprets it,
X * opens the input and signature files (if necessary), and
X * then invokes the proper routine to sign/check/whatever.
X */
Xvoid 
Xmain (argc, argv)
X	int     argc;
X	char   *argv[];
X{	int	j;
X	int	arg;
X	int	start;
X	int	hashMethod;
X	int	securitySize;
X	int	parameterSize;
X	int	noOfBitsPerVerifier;
X	int	OTTsize;
X	char	sigFileName[MAX_FILE_NAME_SIZE_IN_BYTES];
X	int	msgSize;
X	char	*message;
X	char	msgBuffer[MAX_MESSAGE_SIZE_IN_BYTES];
X	FILE	*inputFile;
X	FILE	*sigFile;
X	word32	publicKey[MAX_PUBLIC_KEY_SIZE];
X	char	dateString[80];
X	char	userName[MAX_USER_NAME_SIZE_IN_BYTES];
X	word32	dateTime32;
X	int	exitCode;
X	long	longTemp;
X	int	publicKeySize;
X	int	silentFlag = FALSE;
X	int	verboseFlag = FALSE;
X	char	*publicDirName;
X	int	errorCount;
X	char	commandString[MAX_FILE_NAME_SIZE_IN_BYTES];
X
X	GetFileSuffix(argv[0], commandString);
X
X	if (strncmp(commandString,"destroyoldkey", 13)==0) {
X		DestroyOldKey();
X		exit(0);
X	}
X	if (argc<2) {
X		fprintf(stdout, "%s\n", VERSION);
X		fprintf(stdout, "Copyright (C) 1990 Xerox Corporation.\n");
X		fprintf(stdout, "EXPERIMENTAL SOFTWARE\n");
X		fprintf(stdout, "See source code header for scope of\n");
X		fprintf(stdout,
X			"license granted and for warranty disclaimers.\n");
X		fprintf(stderr,
X			"Usage: sign [-m message | -] userKey [files]\n");
X		fprintf(stderr,
X			"   or: check [-dpublicDir] [-s] [-v] [files]\n");
X		fprintf(stderr,
X			"   or: makepublickey [options] userKey user-name\n");
X		fprintf(stderr,
X			"   or: dumpsig [files]\n");
X		fprintf(stderr,
X			"   or: destroyoldkey\n");
X		fprintf(stderr,
X			"   or: recoverauxinfo userKey\n");
X		ErrAbort("");
X	};
X
X	if (strncmp(commandString,"sign", 4)==0) {
X		fprintf(stdout, "Copyright (C) 1990 Xerox Corporation.\n");
X		fprintf(stdout, "EXPERIMENTAL SOFTWARE\n");
X		fprintf(stdout, "See source code header for scope of\n");
X		fprintf(stdout,
X			"license granted and for warranty disclaimers.\n");
X		if (argc <= 2)
X			ErrAbort(
X				"Usage: sign [-m message | -] userKey [files]");
X		start = 2;
X		message = "";
X		if (strcmp(argv[1], "-m") == 0) {
X			if (argc <= 3) ErrAbort("No -m message to sign");
X			message = argv[2];
X			start = 4;
X		}
X		else if (strcmp(argv[1], "-") == 0) {
X			msgSize = fread(msgBuffer, 1,
X				MAX_MESSAGE_SIZE_IN_BYTES, stdin);
X			if (msgSize == MAX_MESSAGE_SIZE_IN_BYTES)
X				ErrAbort("message from stdin too big");
X			if (ferror(stdin) != 0) {
X				ErrAbort("Can't read from stdin");
X			};
X			message = msgBuffer;
X			start = 3;
X		}
X		if (argc <= start) 
X			ErrAbort("No files to sign");
X		for(arg=start; arg<argc; arg++) {
X			makeSigFileName(argv[arg], sigFileName);
X			if (SignatureExists(sigFileName) == 0) {
X				fprintf(stderr,
X				"\"%s\" already signed.\n", argv[arg]);
X				continue;
X			};
X			sigFile = fopen(sigFileName, "wb");
X			inputFile = fopen(argv[arg], "rb");
X			if (inputFile == NULL) {
X				fprintf(stderr,
X					"Can't open \"%s\" for read\n",
X					argv[arg]);
X				continue;
X			};
X			if (sigFile == NULL) {
X				fprintf(stderr, "Can't open \"%s\" for write\n",
X					sigFileName);
X				continue;
X			};
X			Sign (argv[start-1], message, inputFile, sigFile);
X			FileClose(inputFile, argv[arg]);
X			FileClose(sigFile, sigFileName);
X		};
X		exit(0);
X	}
X	else if (strncmp(commandString,"makepublickey", 13)==0) {
X		fprintf(stdout, "Copyright (C) 1990 Xerox Corporation.\n");
X		fprintf(stdout, "EXPERIMENTAL SOFTWARE\n");
X		fprintf(stdout, "See source code header for scope of\n");
X		fprintf(stdout,
X			"license granted and for warranty disclaimers.\n");
X		publicDirName = MAKE_KEY_PUB_DIR_NAME;
X		hashMethod = MD4_METHOD;
X		securitySize = 2;
X		parameterSize = 2;
X		noOfBitsPerVerifier = 4;
X		OTTsize = 32;
X		arg = 1;
X		while (argv[arg][0]=='-') {
X			switch(argv[arg][1]) {
X			case 's':	sscanf(&argv[arg][2],"%d",
X						&securitySize);
X					break;
X			case 'p':	sscanf(&argv[arg][2],"%d",
X						&parameterSize);
X					break;
X			case 'b':	sscanf(&argv[arg][2],"%d",
X						&noOfBitsPerVerifier);
X					break;
X			case 'n':	sscanf(&argv[arg][2],"%d",
X						&OTTsize);
X					break;
X			case 'd':	publicDirName = &argv[arg][2];
X					break;
X			case 'h':	hashMethod = SelectHashMethod(
X							&argv[arg][2]);
X					break;
X			default:	fprintf(stderr,
X					"Bad arg: \"%s\" ignored.", argv[arg]);
X					break;
X			};
X			if (++arg == argc) break;
X		};
X		if (arg+2 != argc) {
X			fprintf(stderr,
X			"Usage: makepublickey [options] userKey name\n");
X			fprintf(stderr,
X			"Standard directories are:\n%s\n%s\n%s\n%s\n%s\n",
X				PUBLIC_DIRECTORY_NAME,
X				MAKE_KEY_PUB_DIR_NAME,
X				STABLE1_DIRECTORY,
X				STABLE2_DIRECTORY,
X				AUX_INFO_DIRECTORY);
X			ErrAbort("");
X		};
X		fprintf(stderr, "-nUser Name        : \"%s\"\n", argv[arg+1]);
X		fprintf(stderr, "-hhash method      : %s\n",
X			NameForHashMethod(hashMethod));
X		fprintf(stderr, "-ssecurity size    : %d\n", securitySize);
X		fprintf(stderr, "-pparameter size   : %d\n", parameterSize);
X		fprintf(stderr, "-bbits per verifier: %d\n", noOfBitsPerVerifier);
X		fprintf(stderr, "-nOTT size         : %d\n", OTTsize);
X		fprintf(stderr, "-dpublic directory : %s\n", publicDirName);
X		CreateSignCheckPair(argv[arg], argv[arg+1], publicDirName,
X			hashMethod, securitySize,
X			parameterSize, noOfBitsPerVerifier, OTTsize);
X		exit(0);
X	}
X	else if (strncmp(commandString,"check", 5)==0) {
X		publicDirName = PUBLIC_DIRECTORY_NAME;
X		errorCount = 0;
X		for(arg=1; arg<argc; arg++) {
X			if (strcmp(argv[arg], "-s") == 0) {
X				silentFlag = TRUE;
X				continue;
X			};
X			if (strcmp(argv[arg], "-v") == 0) {
X				verboseFlag = TRUE;
X				continue;
X			};
X			if (strncmp(argv[arg], "-d", 2) == 0) {
X				publicDirName = &argv[arg][2];
X				continue;
X			};
X			if (silentFlag != TRUE) {
X				fprintf(stdout,
X				"Copyright (C) 1990 Xerox Corporation.\n");
X				fprintf(stdout,
X				"EXPERIMENTAL SOFTWARE\n");
X				fprintf(stdout,
X				"See source code header for scope of\n");
X				fprintf(stdout,
X			"license granted and for warranty disclaimers.\n");
X			};
X			makeSigFileName(argv[arg], sigFileName);
X			inputFile = fopen(argv[arg], "rb");
X			sigFile = fopen(sigFileName, "rb");
X			if (inputFile == NULL) {
X				if (silentFlag != TRUE)
X					fprintf(stderr,
X						"Can't open \"%s\" for read\n",
X						argv[arg]);
X				errorCount++;
X				continue;
X			};
X			if (sigFile == NULL) {
X				if (silentFlag != TRUE)
X					fprintf(stderr,
X						"Can't open \"%s\" for read\n",
X						sigFileName);
X				FileClose(inputFile, argv[arg]);
X				errorCount++;
X				continue;
X			};
X			Check(inputFile, sigFile, publicKey,
X				&dateTime32, msgBuffer);
X			FileClose(inputFile, argv[arg]);
X			FileClose(sigFile, sigFileName);
X			exitCode = LookUpPublicKey (publicKey,
X				publicDirName, userName);
X			if (exitCode != 0)
X				errorCount++;
X			if (silentFlag == TRUE)
X				continue;
X			if (exitCode == 0) {
X				longTemp = dateTime32;
X				strcpy(dateString, ctime(&longTemp));
X				if (dateString[strlen(dateString)-1] == '\n')
X					dateString[strlen(dateString)-1] =
X						(char) 0;
X				fprintf(stdout,
X					"\"%s\" signed by \"%s\" on %s.\n",
X					argv[arg], userName, dateString);
X				if (	(msgBuffer[0] != 0) &&
X					(verboseFlag == TRUE))
X					fprintf(stdout, "Message: \"%s\"\n",
X						msgBuffer);
X			}
X			else {
X				fprintf(stdout,
X				"\"%s\" signature invalid.\n",
X					argv[arg]);
X				if (verboseFlag == TRUE) {
X					fprintf(stdout, "Computed public key=");
X					publicKeySize =
X					ComputePublicKeySize(publicKey);
X					for (j=0; j<publicKeySize; j++)
X						fprintf(stdout, " %08lx",
X					publicKey[j]);
X					fprintf(stdout, "\n");
X				};
X			};
X		};
X		if (silentFlag != TRUE) {
X			if (errorCount == 0)
X				fprintf(stderr, "No errors.\n");
X			else
X				fprintf(stderr, "%d error(s) encountered\n",
X					errorCount);
X		};
X		exit(errorCount);
X	}
X	else if (strncmp(commandString,"dumpsig", 7)==0) {
X		for(arg=1; arg<argc; arg++) {
X			makeSigFileName(argv[arg], sigFileName);
X			sigFile = fopen(sigFileName, "rb");
X			if (sigFile == (FILE*)NULL)
X				fprintf(stderr, "Can't open \"%s\" for read\n",
X					sigFileName);
X			else {
X				fprintf(stdout,
X					"Dumping signature file \"%s\"\n",
X					sigFileName);
X				DumpSig(sigFile);
X				FileClose(sigFile, sigFileName);
X			};
X		};
X		exit(0);
X	}
X	else if (strncmp(commandString,"recoverauxinfo", 14)==0) {
X		if (argc != 2)
X			ErrAbort("Usage: recoverauxinfo userKey");
X		RecoverAuxInfo(argv[1]);
X		exit(0);
X	}
X	else
X		ErrAbort("Executable file must be named \"sign\",\
X \"check\", \"dumpsig\", \"destroyoldkey\",\
X \"recoverauxinfo\" or \"makepublickey\".");
X}
END_OF_FILE
if test 130003 -ne `wc -c <'signCheck1.0.c'`; then
    echo shar: \"'signCheck1.0.c'\" unpacked with wrong size!
fi
# end of 'signCheck1.0.c'
fi
if test -f 'test' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test'\"
else
echo shar: Extracting \"'test'\" \(24 characters\)
sed "s/^X//" >'test' <<'END_OF_FILE'
XThis is a test message.
END_OF_FILE
if test 24 -ne `wc -c <'test'`; then
    echo shar: \"'test'\" unpacked with wrong size!
fi
# end of 'test'
fi
if test -f 'testit' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testit'\"
else
echo shar: Extracting \"'testit'\" \(188 characters\)
sed "s/^X//" >'testit' <<'END_OF_FILE'
X#! /bin/csh
X./destroyoldkey
X./makepublickey -n4 key "Fred Farckle"
Xgrep public privDir/*
Xwhile (1)
Xgrep path privDir/*
Xgrep toggle privDir/*
Xrm -f .JZtest
X./sign key test
X./check test
Xend
END_OF_FILE
if test 188 -ne `wc -c <'testit'`; then
    echo shar: \"'testit'\" unpacked with wrong size!
fi
chmod +x 'testit'
# end of 'testit'
fi
if test -f 'wellKnownDirectories' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wellKnownDirectories'\"
else
echo shar: Extracting \"'wellKnownDirectories'\" \(214 characters\)
sed "s/^X//" >'wellKnownDirectories' <<'END_OF_FILE'
X/* For Experimental use
X */
X#define PUBLIC_DIRECTORY_NAME "pubDir"
X#define MAKE_KEY_PUB_DIR_NAME "pubDir"
X#define STABLE1_DIRECTORY "privDir"
X#define STABLE2_DIRECTORY "privDir"
X#define AUX_INFO_DIRECTORY "auxDir"
END_OF_FILE
if test 214 -ne `wc -c <'wellKnownDirectories'`; then
    echo shar: \"'wellKnownDirectories'\" unpacked with wrong size!
fi
# end of 'wellKnownDirectories'
fi
echo shar: End of shell archive.
exit 0
